%!PS-Adobe-2.0 EPSF-2.0
%%BoundingBox: 42 455 465 721
%%HiResBoundingBox: 42.054 455.611 464.355 720.022
%%Creator: dvips(k) 5.992 Copyright 2012 Radical Eye Software
%%Title: foo.dvi
%%CreationDate: Mon May  5 08:45:06 2014
%%DocumentFonts: CMR10 CMSY10
%%EndComments
%DVIPSWebPage: (www.radicaleye.com)
%DVIPSCommandLine: dvips -E foo.dvi -o foo.eps
%DVIPSParameters: dpi=600
%DVIPSSource:  TeX output 2014.05.05:0845
%%BeginProcSet: tex.pro 0 0
%!
/TeXDict 300 dict def TeXDict begin/N{def}def/B{bind def}N/S{exch}N/X{S
N}B/A{dup}B/TR{translate}N/isls false N/vsize 11 72 mul N/hsize 8.5 72
mul N/landplus90{false}def/@rigin{isls{[0 landplus90{1 -1}{-1 1}ifelse 0
0 0]concat}if 72 Resolution div 72 VResolution div neg scale isls{
landplus90{VResolution 72 div vsize mul 0 exch}{Resolution -72 div hsize
mul 0}ifelse TR}if Resolution VResolution vsize -72 div 1 add mul TR[
matrix currentmatrix{A A round sub abs 0.00001 lt{round}if}forall round
exch round exch]setmatrix}N/@landscape{/isls true N}B/@manualfeed{
statusdict/manualfeed true put}B/@copies{/#copies X}B/FMat[1 0 0 -1 0 0]
N/FBB[0 0 0 0]N/nn 0 N/IEn 0 N/ctr 0 N/df-tail{/nn 8 dict N nn begin
/FontType 3 N/FontMatrix fntrx N/FontBBox FBB N string/base X array
/BitMaps X/BuildChar{CharBuilder}N/Encoding IEn N end A{/foo setfont}2
array copy cvx N load 0 nn put/ctr 0 N[}B/sf 0 N/df{/sf 1 N/fntrx FMat N
df-tail}B/dfs{div/sf X/fntrx[sf 0 0 sf neg 0 0]N df-tail}B/E{pop nn A
definefont setfont}B/Cw{Cd A length 5 sub get}B/Ch{Cd A length 4 sub get
}B/Cx{128 Cd A length 3 sub get sub}B/Cy{Cd A length 2 sub get 127 sub}
B/Cdx{Cd A length 1 sub get}B/Ci{Cd A type/stringtype ne{ctr get/ctr ctr
1 add N}if}B/CharBuilder{save 3 1 roll S A/base get 2 index get S
/BitMaps get S get/Cd X pop/ctr 0 N Cdx 0 Cx Cy Ch sub Cx Cw add Cy
setcachedevice Cw Ch true[1 0 0 -1 -.1 Cx sub Cy .1 sub]{Ci}imagemask
restore}B/D{/cc X A type/stringtype ne{]}if nn/base get cc ctr put nn
/BitMaps get S ctr S sf 1 ne{A A length 1 sub A 2 index S get sf div put
}if put/ctr ctr 1 add N}B/I{cc 1 add D}B/bop{userdict/bop-hook known{
bop-hook}if/SI save N @rigin 0 0 moveto/V matrix currentmatrix A 1 get A
mul exch 0 get A mul add .99 lt{/QV}{/RV}ifelse load def pop pop}N/eop{
SI restore userdict/eop-hook known{eop-hook}if showpage}N/@start{
userdict/start-hook known{start-hook}if pop/VResolution X/Resolution X
1000 div/DVImag X/IEn 256 array N 2 string 0 1 255{IEn S A 360 add 36 4
index cvrs cvn put}for pop 65781.76 div/vsize X 65781.76 div/hsize X}N
/dir 0 def/dyy{/dir 0 def}B/dyt{/dir 1 def}B/dty{/dir 2 def}B/dtt{/dir 3
def}B/p{dir 2 eq{-90 rotate show 90 rotate}{dir 3 eq{-90 rotate show 90
rotate}{show}ifelse}ifelse}N/RMat[1 0 0 -1 0 0]N/BDot 260 string N/Rx 0
N/Ry 0 N/V{}B/RV/v{/Ry X/Rx X V}B statusdict begin/product where{pop
false[(Display)(NeXT)(LaserWriter 16/600)]{A length product length le{A
length product exch 0 exch getinterval eq{pop true exit}if}{pop}ifelse}
forall}{false}ifelse end{{gsave TR -.1 .1 TR 1 1 scale Rx Ry false RMat{
BDot}imagemask grestore}}{{gsave TR -.1 .1 TR Rx Ry scale 1 1 false RMat
{BDot}imagemask grestore}}ifelse B/QV{gsave newpath transform round exch
round exch itransform moveto Rx 0 rlineto 0 Ry neg rlineto Rx neg 0
rlineto fill grestore}B/a{moveto}B/delta 0 N/tail{A/delta X 0 rmoveto}B
/M{S p delta add tail}B/b{S p tail}B/c{-4 M}B/d{-3 M}B/e{-2 M}B/f{-1 M}
B/g{0 M}B/h{1 M}B/i{2 M}B/j{3 M}B/k{4 M}B/w{0 rmoveto}B/l{p -4 w}B/m{p
-3 w}B/n{p -2 w}B/o{p -1 w}B/q{p 1 w}B/r{p 2 w}B/s{p 3 w}B/t{p 4 w}B/x{
0 S rmoveto}B/y{3 2 roll p a}B/bos{/SS save N}B/eos{SS restore}B end

%%EndProcSet
%%BeginProcSet: pstricks.pro 0 0
% $Id: pstricks.pro 647 2012-02-12 15:03:40Z herbert $
%
%% PostScript prologue for pstricks.tex.
%% Version 1.12, 2012/02/12
%%
%% This program can be redistributed and/or modified under the terms
%% of the LaTeX Project Public License Distributed from CTAN archives
%% in directory macros/latex/base/lppl.txt.
%
%
% Define the follwing gs-functions if not known, eg when using distiller
%
systemdict /.setopacityalpha known not {/.setopacityalpha { pop } def } if
systemdict /.setblendmode known not {/.setblendmode { pop } def } if
systemdict /.setshapealpha known not {/.setshapealpha { pop } def } if
%
/tx@Dict 200 dict def 				% the main PSTricks dictionary
tx@Dict begin
/ADict 25 dict def				% The arrow dictionaray
/CM { matrix currentmatrix } bind def
/SLW /setlinewidth load def
/CLW /currentlinewidth load def
/CP /currentpoint load def
/ED { exch def } bind def
/L /lineto load def
/T /translate load def
/TMatrix { } def
/RAngle { 0 } def
/Sqrt { dup 0 lt { pop 0 } { sqrt } ifelse } def  % return 0 for negative arguments 
/Atan { /atan load stopped { pop pop 0 } if } def % return 0 if atan not known
/ATAN1 {neg -1 atan 180 sub } def		% atan(x) (only one parameter)
/Div { dup 0 eq { pop } { div } ifelse } def  	% control the division
/tan { dup cos abs 1.e-10 lt 
  { pop 1.e10 } 				% return 1.e10 as infinit
  { dup sin exch cos div } ifelse 		% default sin/cos
} def
/Tan { dup sin exch cos Div } def 		% sin(x)/cos(x) x in degrees
/Acos {dup dup mul neg 1 add dup 0 lt {		% arc cos, returns 0 when negative root
  pop pop 0 }{ sqrt exch atan} ifelse } def
/NET { neg exch neg exch T } def	      	% change coordinate system to the negative one		
/Pyth { dup mul exch dup mul add sqrt } def   	% Pythagoras, expects 2 parameter
/Pyth2 {					% Pythagoras, xA yA xB yB
  3 -1 roll 		% xA xB yB yA
  sub			% xA xB yB-yA
  3 1 roll 		% yB-yA xA xB
  sub			% yB-yA xA-xB
  Pyth } def
/PtoC { 2 copy cos mul 3 1 roll sin mul } def 	% Polar to Cartesian
/Rand { rand 4294967295 div } def		% a real random number
%----------------- hv added 20050516 ---------------
/PiDiv2 1.57079632680 def
/Pi 3.14159265359 def 
/TwoPi 6.28318530718 def
/Euler 2.71828182846 def 
%/e Euler bind def
%
/RadtoDeg { 180 mul Pi div } bind def 		% convert from radian to degrees
/DegtoRad { Pi mul 180 div } bind def 		% viceversa
%----------------- hv end---------------------------
/PathLength@ { /z z y y1 sub x x1 sub Pyth add def /y1 y def /x1 x def } def
%
/PathLength { 
  flattenpath /z 0 def 
  { /y1 ED /x1 ED /y2 y1 def /x2 x1 def }
  { /y ED /x ED PathLength@ } 
  {} 
  { /y y2 def /x x2 def PathLength@ }
  /pathforall load stopped { pop pop pop pop } if 
  z 
} def
%
/STP { .996264 dup scale } def			% BP/PT scaling
/STV { SDict begin normalscale end STP  } def	% 
%
/DashLine {
    dup 0 gt
    { /a .5 def PathLength exch div }
    { pop /a 1 def PathLength } ifelse
    /b ED % pattern should fit evenly in b
    dup /X ED % pattern array
    0 get /y ED % length of first black segment
    /z 0 X {add} forall def % length of the full pattern
    %% Computation of the scaling factor as described by van Zandt:
    b a .5 sub 2 mul y mul sub z Div round
    z mul a .5 sub 2 mul y mul add b exch Div
    %%%% scaling factor on stack.
    /z ED %% now, z is the scaling factor
    false % for the length test below
    X { z mul } forall X astore %% modification TN 04-08-07
    %%% Checking whether at least one dash in X has positive length:
    {0 gt or} forall
    { X 1 a sub y mul }
    { [ 1 0 ] 0 }
    ifelse
    setdash stroke
} def
%
/DotLine { 
  /b PathLength def 
  /a ED /z ED /y CLW def 
  /z y z add def 
  a 0 gt { 
    /b b a div def 
  }{ 
    a 0 eq { 
      /b b y sub def 
    }{ a -3 eq { 
      /b b y add def } if 
    } ifelse 
  } ifelse 
  [ 0 b b z Div round Div dup 0 le { pop 1 } if ] 
  a 0 gt { 0 }{ y 2 div a -2 gt { neg }if } ifelse 
  setdash 1 setlinecap stroke 
} def
%
/SymbolLine {   % on stack [ x y x y ...
  counttomark 					% number of elements
  2 div cvi /n ED     				% n pairs
  /YA ED /XA ED					% the start point
  n 1 sub { 
    /YB ED /XB ED
    /XLength XB XA sub def
    /YLength YB YA sub def
    /PAngle YLength XLength Atan def
    /XYLength XLength YLength Pyth def

    %% for negative SymStep we calculate the distance 
    SymStep 0 lt 
      { %XYLength SymStep div abs cvi 
        /nSym SymStep abs cvi def } 
      { /nSym XYLength SymStep div cvi def }
    ifelse
    0.5 setflat
    /Shift Symbol stringwidth pop 2 div def 
    /deltaX XLength nSym div def
    /deltaY YLength nSym div def
    curveticks 
      { XA YA moveto }
      { XA Shift sub YA Shift sub moveto }
    ifelse 
    nSym { 
      gsave 
      curveticks 
        { PAngle 180 sub CorrAngle sub tickAngle add /rotAngle ED  
          currentpoint translate rotAngle rotate 
          0 SymbolWidth 2 div moveto 0 SymbolWidth 2 div neg lineto 
          SymbolLinewidth setlinewidth stroke
        }
        { 
          rotateSymbol { PAngle 180 sub CorrAngle sub rotate } if
          Symbol show 
        }
      ifelse 
      grestore 
      deltaX deltaY rmoveto
    } repeat
    /YA YB def /XA XB def
  } repeat 
  curveticks 
    { XA YA moveto }
    { XA Shift sub YA Shift sub moveto }
  ifelse 
  gsave 
  curveticks 
    { PAngle 180 sub CorrAngle sub tickAngle add /rotAngle ED  
      XA YA translate rotAngle rotate 
      0 SymbolWidth 2 div moveto 0 SymbolWidth 2 div neg lineto 
      SymbolLinewidth setlinewidth stroke
    }
    { 
      rotateSymbol { PAngle 180 sub CorrAngle sub rotate } if
      Symbol show 
    }
  ifelse 
  grestore
  pop 				% delete the mark symbol
} def
%
/LineFill { % hv ------------ patch 7 -------------
  gsave 
  abs /hatchWidthInc ED
  abs /hatchSepInc ED
  abs CLW add /a ED 
  a 0 dtransform round exch round exch
  2 copy idtransform 
  exch Atan rotate 
  idtransform pop /a ED 
  .25 .25 itransform pathbbox 
  /y2 ED 
  a Div ceiling cvi /x2 ED /y1 ED 
  a Div cvi /x1 ED /y2 y2 y1 sub def 
  clip 
  newpath 
  2 setlinecap 
  systemdict
  /setstrokeadjust known { true setstrokeadjust } if 
  x2 x1 sub 1 add { 
    x1 a mul y1 moveto 0 y2 rlineto stroke 
    /x1 x1 1 add 
      hatchWidthInc 0 gt { CLW add } if 
    def 
    hatchSepInc 0 gt hatchWidthInc 0 gt or { 
      /a a hatchSepInc add def
      CLW hatchWidthInc add SLW 
    } if
  } repeat 
  grestore 
  pop pop } def
%
/DotFill {%	 on stack: dot radius
  /dotRadius ED
  abs CLW add /a ED 
  a 0 dtransform round exch round exch
  2 copy idtransform 
  exch Atan rotate 
  idtransform pop /a ED 
  .25 .25 itransform 
  pathbbox % llx lly urx ury of smallest bounding box
  /y2 ED /x2 ED /y1 ED /x1 ED 
  y2 y1 sub a div 2 add cvi /Ny ED
  x2 x1 sub a div 2 add cvi /Nx ED
  clip 
  newpath 
  /yA y1 dotRadius add CLW add def
  /xA0 x1 dotRadius add CLW add def
  Ny {
     /xA xA0 def
     Nx { 
       newpath 
       xA yA dotRadius 0 360 arc 
       SolidDot { gsave fill grestore } if 
       stroke
       xA a add /xA ED
     } repeat
     yA a add /yA ED
  } repeat
  grestore
} def
%
/PenroseFill {%	 on stack: scaling factor
  dup dup scale
  1 exch div round /penroseFactor ED 
  a 0 dtransform round exch round exch
  2 copy idtransform 
  exch Atan rotate 
  idtransform pop /a ED 
  .25 .25 itransform pathbbox 
  /y2 ED 
  a Div ceiling cvi /x2 ED /y1 ED 
  a Div cvi /x1 ED /y2 y2 y1 sub def 
  clip 
  newpath 
  systemdict
  /setstrokeadjust known { true setstrokeadjust } if 
  /I/S/L/W/G/+/Z/F/E/D[/def/exch/for{E D}/add{s E get mul}
 { Z -36.2001 1 33 }{25 E S rlineto}{/q Z dup q G E q 1 + G}{Z 2 2}]{cvx def}forall
  [0 72 1008 {dup sin E cos }F ]1 setlinejoin/s W{/a W{/b I 10{/i I 4{/m I moveto
  i m +/j I 10{/l Z b m l + G a l G sub s m get div .2 + floor .3 + 25
  mul j l + S rmoveto}F i L j L stroke }F}F}F}F 
  grestore 
  pop pop 
} def
%
/TruchetFill { %	 on stack: scaling factor
  10 dict begin
  dup dup scale
  1 exch div round /penroseFactor ED 
  a 0 dtransform round exch round exch
  2 copy idtransform 
  exch Atan rotate 
  idtransform pop /a ED 
  .25 .25 itransform pathbbox 
  /y2 ED 
  a Div ceiling cvi /x2 ED /y1 ED 
  a Div cvi /x1 ED /y2 y2 y1 sub def 
  clip 
  newpath 
  systemdict
  /setstrokeadjust known { true setstrokeadjust } if 
  /ma a neg def
  /ha a 2 div def 
  /mha ha neg def
  /tile { 
    rand dup 2 idiv 2 mul eq { 90 rotate } if
    mha mha moveto ha mha lineto
    ha ha lineto mha ha lineto
%    closepath .1 setlinewidth stroke
    contents
  } def
  /contents{ 
    0 ha moveto ha 0 lineto
    0 mha moveto mha 0 lineto
%    1 setlinewidth stroke
  } def
  /dotiling {
    f ma mul a f a mul { 
      /i exch def
      f ma mul a f a mul { 
        /j exch def
        gsave i j translate
        tile stroke grestore
      } for
    } for
  } def
%
  /f 3 def 
  5 srand dotiling 
  end % local user dict
} def
%
/BeginArrow { 
  ADict begin 			% hold it local, for end see EndArrow
  /@mtrx CM def 
  gsave 
  2 copy T 
  2 index sub neg exch 
  3 index sub exch Atan 
  rotate newpath 
} def
%
/EndArrow { @mtrx setmatrix CP grestore end } def % end the ADict
%
/Arrow { 
  CLW mul add dup 
  2 div /w ED 
  mul dup /h ED 
  mul /a ED 
  { 0 h T 1 -1 scale } if 
  w neg h moveto 
  0 0 L w h L w neg a neg rlineto 
  gsave fill grestore 
} def
%
/ArrowD { % the sides are drawn as curves (hv 20071211)
  CLW mul add dup 
  2 div /w ED 
  mul dup /h ED 
  mul /Inset ED 
  { 0 h T 1 -1 scale } if % changes the direction
% we use y=w/h^2 * x^2 as equation for the control points
% for the coordinates the arrow is seen from top to bottom
% the bottom (tip) is (0;0)
  w neg h moveto % lower left of >
  w 9 div 4 mul neg h 3 div 2 mul
  w 9 div neg       h 3 div  
  0 0 curveto    % tip of >
  w 9 div        h 3 div  
  w 9 div 4 mul  h 3 div 2 mul
  w h curveto % upper left of >
  w neg Inset neg rlineto % move to x=0 and inset
  gsave fill grestore 
} def 
%
/Tbar { 
  CLW mul add /z ED 
  z -2 div CLW 2 div moveto 
  z 0 rlineto stroke 
  0 CLW moveto 
} def
%
/Bracket { 
  CLW mul add dup CLW sub 2 div 
  /x ED mul CLW add /y ED /z CLW 2 div def 
  x neg y moveto 
  x neg CLW 2 div L x CLW 2 div L x y L stroke 
  0 CLW moveto 
} def
%
/RoundBracket { 
  CLW mul add dup 2 div 
  /x ED mul /y ED /mtrx CM def 
  0 CLW 2 div T x y mul 0 ne { x y scale } if 
  1 1 moveto 
  .85 .5 .35 0 0 0 curveto 
  -.35 0 -.85 .5 -1 1 curveto 
  mtrx setmatrix stroke 0 CLW moveto 
} def
%
/SD { 0 360 arc fill } def
%
/EndDot { % DS is the dot size 
  { /z DS def } { /z 0 def } ifelse  	% outer or inner dimen 
  /b ED 				% the color definition
  0 z DS SD 
  b { 0 z DS CLW sub SD } if 
  0 DS z add CLW 4 div sub 
  moveto 
} def
%
/Shadow { [ { /moveto load } { /lineto load } { /curveto load } {
  /closepath load } /pathforall load stopped { pop pop pop pop CP /moveto
  load } if ] cvx newpath 3 1 roll T exec } def
%
/NArray { % holds the coordinates and on top of stack the showpoints boolean
  /showpoints ED 
  counttomark 2 div dup cvi /n ED  	% n 2 div on stack 
  n eq not { exch pop } if		% even numbers of points? delete one
  ] aload /Points ED 
  showpoints not { Points aload pop } if
%    { ] aload /Points ED } 
%    { n 2 mul 1 add -1 roll pop } ifelse	% delete the mark symbol 
} def
%
/Line { 
  NArray n 0 eq not 
    { n 1 eq { 0 0 /n 2 def } if ArrowA /n n 2 sub def 
      n { Lineto } repeat 
      CP 4 2 roll ArrowB L pop pop 
    } if 
} def
%
/LineToYAxis {
  /Ox ED		% Save the x origin value 
  NArray            % all x-y pairs on stack
  n { 2 copy moveto % go to current point
    Ox exch Lineto   % line to y-axis
    pop             % delete old x-value
  } repeat
} def
%
/LineToXAxis{
  /Oy ED		% Save the y origin value 
  NArray		% all x-y pairs on stack
  n 0 eq not
    { n 1 eq { 0 0 /n 2 def } if
      ArrowA
      /n n 2 sub def
      CP 2 copy moveto pop Oy Lineto
      n { 2 copy moveto pop Oy Lineto } repeat
      CP
      4 2 roll
      ArrowB
      2 copy moveto pop Oy
      L
      pop pop } if
} def
%
/Arcto { 
  /a [ 6 -2 roll ] cvx def 
  a r 
  /arcto load stopped { 5 } { 4 } ifelse { pop } repeat 
  a 
} def
%
/CheckClosed { 
  dup n 2 mul 1 sub index eq 2 index n 2 mul 1 add index eq
  and { pop pop /n n 1 sub def } if 
} def
%
/Polygon { 
  NArray n 2 eq { 0 0 /n 3 def } if 
  n 3 lt 
    { n { pop pop } repeat } 
    { n 3 gt { CheckClosed } if 
      n 2 mul -2 roll 
      /y0 ED /x0 ED /y1 ED /x1 ED  
      x1 y1 
      /x1 x0 x1 add 2 div def 
      /y1 y0 y1 add 2 div def 
      x1 y1 moveto 
      /n n 2 sub def 
      n { Lineto } repeat 
      x1 y1 x0 y0 6 4 roll Lineto
      Lineto pop pop closepath } ifelse 
} def
%
/SymbolPolygon {   % on stack [ x y x y ...
  counttomark 					% number of elements
  2 add /m ED
  2 copy m 2 roll				% copy last two
  m 2 div cvi /n ED    				% n pairs
  /YA ED /XA ED					% the start point
  n 1 sub { 
    /YB ED /XB ED
    /XLength XB XA sub def
    /YLength YB YA sub def
    /PAngle YLength XLength Atan def
    /XYLength XLength YLength Pyth def
    /nSym XYLength SymStep Div cvi def
    /Shift Symbol stringwidth pop 2 Div def 
    /deltaX XLength nSym Div def
    /deltaY YLength nSym Div def
    XA Shift sub YA Shift sub moveto 
    nSym { 
      gsave rotateSymbol { PAngle 180 sub CorrAngle sub rotate } if
      Symbol show 
      grestore 
      deltaX deltaY rmoveto
    } repeat
%    XB Shift sub YB Shift sub moveto Symbol show
    /YA YB def /XA XB def
  } repeat 
  pop	% delete the mark symbol
} def
%
/Diamond { 
  /mtrx CM def 
  T rotate 
  /h ED 
  /w ED 
  dup 0 eq { pop } { CLW mul neg 
    /d ED 
    /a w h Atan def 
    /h d a sin Div h add def 
    /w d a cos Div w add def } ifelse 
  mark w 2 div h 2 div w 0 0 h neg w neg 0 0 h w 2 div h 2 div 
  /ArrowA { moveto } def 
  /ArrowB { } def 
  false Line 
  closepath mtrx setmatrix } def
%
/Triangle { 
  /mtrx CM def 
  translate 
  rotate /h ED 2 div /w ED 
  dup CLW mul /d ED 
  /h h d w h Atan sin Div sub def 
  /w w d h w Atan 2 div dup cos exch sin Div mul sub def 
  mark 
  0 d w neg d 0 h w d 0 d 
  /ArrowA { moveto } def 
  /ArrowB { } def 
  false 
  Line 
  closepath 
  mtrx
% DG/SR modification begin - Jun.  1, 1998 - Patch 3 (from Michael Vulis)
% setmatrix } def
  setmatrix pop 
} def
% DG/SR modification end
%
/CCA { 
  /y ED /x ED 
  2 copy y sub /dy1 ED 
  x sub /dx1 ED 
  /l1 dx1 dy1 Pyth def 
} def
%
/CC { 
  /l0 l1 def 
  /x1 x dx sub def 
  /y1 y dy sub def 
  /dx0 dx1 def 
  /dy0 dy1 def 
  CCA 
  /dx dx0 l1 c exp mul dx1 l0 c exp mul add def 
  /dy dy0 l1 c exp mul dy1 l0 c exp mul add def 
  /m dx0 dy0 Atan dx1 dy1 Atan sub 2 div cos abs b exp a mul dx dy Pyth Div 2 div def 
  /x2 x l0 dx mul m mul sub def
  /y2 y l0 dy mul m mul sub def 
  /dx l1 dx mul m mul neg def 
  /dy l1 dy mul m mul neg def 
} def
%
/IC { 
  /c c 1 add def 
  c 0 lt { /c 0 def } { c 3 gt { /c 3 def } if } ifelse 
  /a a 2 mul 3 div 45 cos b exp div def 
  CCA 
  /dx 0 def 
  /dy 0 def 
} def
%
/BOC { IC CC x2 y2 x1 y1 ArrowA CP 4 2 roll x y curveto } def
/NC { CC x1 y1 x2 y2 x y curveto } def
/EOC { x dx sub y dy sub 4 2 roll ArrowB 2 copy curveto } def
/BAC { IC CC x y moveto CC x1 y1 CP ArrowA } def
/NAC { x2 y2 x y curveto CC x1 y1 } def
/EAC { x2 y2 x y ArrowB curveto pop pop } def
%
/OpenCurve { 
  NArray n 3 lt 
    { n { pop pop } repeat } 
    { BOC /n n 3 sub def n { NC } repeat EOC } ifelse 
} def
%
/CurvePath { 
  %% for negative SymStep we calculate the distance 
  SymStep 0 lt { gsave PathLength SymStep div abs /SymStep ED grestore } if
  0.5 setflat
  flattenpath /z 0 def /z0 0 def
  { /y1 ED /x1 ED /y2 y1 def /x2 x1 def 
    x1 Shift sub y1 Shift sub moveto 
    gsave 
    curveticks 
      { x1 y1 translate startAngle rotate 
        0 SymbolWidth 2 div moveto 0 SymbolWidth 2 div neg lineto 
        SymbolLinewidth setlinewidth stroke      
      }
      { startAngle rotate Symbol show }
    ifelse 
    grestore /z0 z def }
  { /y ED /x ED PathLength@ z z0 sub SymStep ge {
      x Shift sub y Shift sub moveto 
      gsave 
      curveticks 
        { y yOld sub x xOld sub Atan 180 sub CorrAngle sub /rotAngle ED  
          x y translate rotAngle rotate 
          0 SymbolWidth 2 div moveto 0 SymbolWidth 2 div neg lineto 
          SymbolLinewidth setlinewidth stroke
        }
        { 
          rotateSymbol { y yOld sub x xOld sub Atan 180 sub CorrAngle sub rotate } if        
          Symbol show 
        }
      ifelse 
      grestore /z0 z def } if 
    /yOld y def /xOld x def } 
  {} %% the lineto part
  { /y y2 def /x x2 def PathLength@ 
    x Shift sub y Shift sub moveto 
    gsave
    curveticks 
      { y yOld sub x xOld sub Atan 180 sub /rotAngle ED  
        x y translate rotAngle rotate 
        0 SymbolWidth 2 div moveto 0 SymbolWidth 2 div neg lineto 
        SymbolLinewidth setlinewidth stroke
      }
      { 
        x Shift sub y Shift sub moveto 
        rotateSymbol { y yOld sub x xOld sub Atan 180 sub CorrAngle sub rotate } if        
        Symbol show 
      }
    ifelse 
    grestore
  }
  pathforall 
%  curveticks 
%   { gsave 
%     x y translate rotAngle rotate 
%     0 SymbolWidth 2 div moveto 0 SymbolWidth 2 div neg lineto 
%     SymbolLinewidth setlinewidth stroke grestore
%   } if
  z 
} def
%
/OpenSymbolCurve { 
  OpenCurve
  0.1 setflat
  /Shift Symbol stringwidth pop 2 div def 
  CurvePath 
} def
%
/AltCurve { 
  { false NArray n 2 mul 2 roll 
    [ n 2 mul 3 sub 1 roll ] aload
    /Points ED 
    n 2 mul -2 roll } 
  { false NArray } ifelse 
  n 4 lt { n { pop pop } repeat } { BAC /n n 4 sub def n { NAC } repeat EAC } ifelse 
} def
%
/AltOpenSymbolCurve { 
  AltCurve
  0.1 setflat
  /Shift Symbol stringwidth pop 2 div def 
  CurvePath 
} def
%
/ClosedCurve { 
  NArray n 3 lt 
    { n { pop pop } repeat } 
    { n 3 gt { CheckClosed } if 
      6 copy n 2 mul 6 add 6 roll 
      IC CC x y moveto n { NC } repeat 
      closepath pop pop 
    } ifelse 
} def
%
/ClosedSymbolCurve { 
  ClosedCurve
  0.1 setflat
  /Shift Symbol stringwidth pop 2 div def 
  CurvePath 
} def
%
/SQ { /r ED r r moveto r r neg L r neg r neg L r neg r L fill } def
/ST { /y ED /x ED x y moveto x neg y L 0 x L fill } def
/SP { /r ED gsave 0 r moveto 4 { 72 rotate 0 r L } repeat fill grestore } def
%
/FontDot { 
  DS 2 mul dup 
  matrix scale matrix concatmatrix exch matrix
  rotate matrix concatmatrix exch 
  findfont exch makefont setfont 
} def
%
/Rect { 
  x1 y1 y2 add 2 div moveto 
  x1 y2 lineto 
  x2 y2 lineto 
  x2 y1 lineto
  x1 y1 lineto 
  closepath 
} def
%
/OvalFrame { 
  x1 x2 eq y1 y2 eq or 
    { pop pop x1 y1 moveto x2 y2 L } 
    { y1 y2 sub abs x1 x2 sub abs 2 copy gt 
      { exch pop } { pop } ifelse 
      2 div exch { dup 3 1 roll mul exch } if 
      2 copy lt { pop } { exch pop } ifelse
      /b ED 
      x1 y1 y2 add 2 div moveto 
      x1 y2 x2 y2 b arcto 
      x2 y2 x2 y1 b arcto
      x2 y1 x1 y1 b arcto 
      x1 y1 x1 y2 b arcto 
      16 { pop } repeat 
      closepath 
    } ifelse 
} def
%
/Frame { 
  CLW mul /a ED 
  3 -1 roll 
  2 copy gt { exch } if 
  a sub /y2 ED 
  a add /y1 ED 
  2 copy gt { exch } if 
  a sub /x2 ED 
  a add /x1 ED 
  1 index 0 eq { pop pop Rect } { OvalFrame } ifelse 
} def
%
/BezierNArray { 
  /f ED 
  counttomark 2 div dup cvi /n ED 
  n eq not { exch pop } if 
  n 1 sub neg 3 mod 3 add 3 mod { 0 0 /n n 1 add def } repeat 
  f { ] aload /Points ED } { n 2 mul 1 add -1 roll pop } ifelse 
} def
%
/OpenBezier { 
  BezierNArray 
  n 1 eq 
    { pop pop } 
    { ArrowA n 4 sub 3 idiv 
      { 6 2 roll 4 2 roll curveto } repeat 
      6 2 roll 4 2 roll ArrowB curveto } ifelse 
} def
%
/OpenSymbolBezier { 
  OpenBezier
  0.1 setflat
  /Shift Symbol stringwidth pop 2 div def 
  CurvePath 
} def
%
/ClosedBezier { 
  BezierNArray 
  n 1 eq 
    { pop pop } 
    { moveto n 1 sub 3 idiv 
      { 6 2 roll 4 2 roll curveto } repeat 
      closepath } ifelse 
} def
%
/ClosedSymbolBezier { 
  /f ED				 % save showpoints value 
  2 copy /yEnd ED /xEnd ED
  counttomark -2 roll 2 copy /yStart ED /xStart ED
  counttomark 2 roll
  f
  ClosedBezier
  0.1 setflat
  /Shift Symbol stringwidth pop 2 div def 
  CurvePath 
  [ xEnd yEnd xStart yStart SymbolLine 
} def
%
/BezierShowPoints { 
  gsave 
  Points aload length 2 div cvi /n ED 
  moveto 
  n 1 sub { lineto } repeat 
  CLW 2 div SLW [ 4 4 ] 0 setdash stroke 
  grestore 
} def
%
/Parab { 
  /y0 ED /x0 ED /y1 ED /x1 ED 
  /dx x0 x1 sub 3 div def 
  /dy y0 y1 sub 3 div def 
  x0 dx sub y0 dy add x1 y1 ArrowA
  x0 dx add y0 dy add x0 2 mul x1 sub y1 ArrowB 
  curveto 
  /Points [ x1 y1 x0 y0 x0 2 mul x1 sub y1 ] def 
} def
%
/Parab1 { % 1 end  |  0 SP
  /ySP ED /xSP ED /y1 ED /x1 ED 
  /dx xSP x1 sub 3 div def 
  /dy ySP y1 sub 3 div def 
  newpath x1 y1 moveto xSP y1 lineto xSP ySP lineto 
                       x1 ySP lineto closepath clip 
  currentpoint
  newpath moveto
  xSP dx sub ySP dy add x1 y1 ArrowA
  xSP dx add ySP dy add xSP 2 mul x1 sub y1 ArrowB 
  curveto 
  /Points [ x1 y1 xSP ySP xSP 2 mul x1 sub y1 ] def 
} def
%
/Grid { 
  newpath 
  /a 4 string def 
  /b ED % 				psk@gridlabels in pt
  /c ED % 				{ \pst@usecolor\psgridlabelcolor }
  /n ED % 				psk@griddots
  cvi dup 1 lt { pop 1 } if 
  /s ED % 				\psk@subgriddiv
  s div dup 0 eq { pop 1 } if 
  /dy ED s div dup 0 eq { pop 1 } if %	\pst@number\psyunit abs
  /dx ED dy div round dy mul %		\pst@number\psxunit abs
  /y0 ED dx div round dx mul 
  /x0 ED dy div round cvi 
  /y2 ED dx div round cvi 
  /x2 ED dy div round cvi 
  /y1 ED dx div round cvi 
  /x1 ED 
  /h y2 y1 sub 0 gt { 1 } { -1 } ifelse def 
  /w x2 x1 sub 0 gt { 1 } { -1 } ifelse def 
  b 0 gt { 
    /z1 b 4 div CLW 2 div add def
%    /Helvetica findfont b scalefont setfont 
    /b b .95 mul CLW 2 div add def } if 
  systemdict /setstrokeadjust known 
    { true setstrokeadjust /t { } def }
    { /t { transform 0.25 sub round 0.25 add exch 0.25 sub round 0.25 add
       exch itransform } bind def } ifelse 
  gsave n 0 gt { 1 setlinecap [ 0 dy n div ] dy n div 2 div setdash } { 2 setlinecap } ifelse 
  /i x1 def 
  /f y1 dy mul n 0 gt { dy n div 2 div h mul sub } if def 
  /g y2 dy mul n 0 gt { dy n div 2 div h mul add } if def 
  x2 x1 sub w mul 1 add dup 1000 gt { pop 1000 } if 
  { i dx mul dup y0 moveto 
    b 0 gt 
      { gsave c i a cvs dup stringwidth pop 
        /z2 ED w 0 gt {z1} {z1 z2 add neg} ifelse 
	h 0 gt {b neg}{z1} ifelse 
        rmoveto show grestore } if 
    dup t f moveto 
    g t L stroke 
    /i i w add def 
  } repeat 
  grestore 
  gsave 
  n 0 gt
  % DG/SR modification begin - Nov. 7, 1997 - Patch 1
  %{ 1 setlinecap [ 0 dx n div ] dy n div 2 div setdash }
    { 1 setlinecap [ 0 dx n div ] dx n div 2 div setdash }
  % DG/SR modification end
    { 2 setlinecap } ifelse 
  /i y1 def 
  /f x1 dx mul n 0 gt { dx n div 2 div w mul sub } if def 
  /g x2 dx mul n 0 gt { dx n div 2 div w mul add } if def 
  y2 y1 sub h mul 1 add dup 1000 gt { pop 1000 } if 
  { newpath i dy mul dup x0 exch moveto 
    b 0 gt { gsave c i a cvs dup stringwidth pop 
      /z2 ED 
      w 0 gt {z1 z2 add neg} {z1} ifelse 
      h 0 gt {z1} {b neg} ifelse 
      rmoveto show grestore } if 
    dup f exch t moveto 
    g exch t L stroke 
    /i i h add def 
  } repeat 
  grestore 
} def
%
/ArcArrow { 
  /d ED /b ED /a ED 
  gsave 
  newpath 0 -1000 moveto clip 
  newpath 
  0 1 0 0 b 
  grestore 
  c mul 
  /e ED 
  pop pop pop r a e d PtoC y add exch x add
  exch r a PtoC y add exch x add exch b pop pop pop pop a e d CLW 8 div c
  mul neg d 
} def
%
/Ellipse { 
  /rotAngle ED
  /mtrx CM def 
  T 
  rotAngle rotate
  scale 0 0 1 5 3 roll arc 
  mtrx setmatrix 
} def
%
/ArcAdjust { %%%% Vincent Guirardel
% given a target length (targetLength) and an initial angle (angle0) [in the stack],
% let  M(angle0)=(rx*cos(angle0),ry*sin(angle0))=(x0,y0).
% This computes an angle t such that (x0,y0) is at distance 
% targetLength from the point M(t)=(rx*cos(t),ry*sin(t)).
% NOTE: this an absolute angle, it does not have to be added or substracted to angle0
% contrary to TvZ's code.
% To achieve, this, one iterates the following process: start with some angle t,
% compute the point M' at distance targetLength of (x0,y0) on the semi-line [(x0,y0) M(t)].
% Now take t' (= new angle) so that (0,0) M(t') and M' are aligned.
%
% Another difference with TvZ's code is that we need d (=add/sub) to be defined.
% the value of d = add/sub is used to know on which side we have to move.
% It is only used in the initialisation of the angle before the iteration.
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Input stack:  1: target length 2: initial angle
% variables used : rx, ry, d (=add/sub)
%
  /targetLength ED /angle0 ED
  /x0 rx angle0 cos mul def
  /y0 ry angle0 sin mul def
% we are looking for an angle t such that (x0,y0) is at distance targetLength 
% from the point M(t)=(rx*cos(t),ry*sin(t)))
%initialisation of angle (using 1st order approx = TvZ's code)
  targetLength 57.2958 mul
  angle0 sin rx mul dup mul
  angle0 cos ry mul dup mul
  add sqrt div 
% if initialisation angle is two large (more than 90 degrees) set it to 90 degrees
% (if the ellipse is very curved at the point where we draw the arrow, %
% the value can be much more than 360 degrees !)
% this should avoid going on the wrong side (more than 180 degrees) or go near
% a bad attractive point (at 180 degrees)
  dup 90 ge { pop 90 } if 
  angle0 exch d % add or sub
% maximum number of times to iterate the iterative procedure:
% iterative procedure: takes an angle t on top of stack, computes a 
% better angle (and put it on top of stack)
  30 { dup
% compute distance D between (x0,y0) and M(t)
    dup cos rx mul x0 sub dup mul exch sin ry mul y0 sub dup mul add sqrt
% if D almost equals targetLength, we stop
    dup targetLength sub abs 1e-5 le { pop exit } if
% stack now contains D t
% compute the point M(t') at distance targetLength of (x0,y0) on the semi-line [(x0,y0) M(t)]:
% M(t')= ( (x(t)-x0)*targetLength/d+x0 , (y(t)-y0)*targetLength/d+y0 )
    exch dup cos rx mul x0 sub  exch sin ry mul y0 sub
% stack contains:  y(t)-y0, x(t)-x0, d
    2 index Div targetLength mul y0 add ry Div exch
    2 index Div targetLength mul x0 add rx Div
% stack contains x(t')/rx , y(t')/ry , d
% now compute t', and remove D from stack
    atan exch pop
  } repeat
% we don't look at what happened... in particular, if targetLength is greater 
% than the diameter of the ellipse...
% the final angle will be around /angle0 + 180. maybe we should treat this pathological case...
% after iteration, stack contains an angle t such that M(t) is the tail of the arrow
% to give back the result as a an angle relative to angle0 we could add the following line:
% angle0 sub 0 exch d
%
% begin bug fix 2006-01-11
% we want to adjust the new angle t' by a multiple of 360 so that  | t'-angle0 | <= 180
%(we don't want to make the ellipse turn more or less than it should)...
dup angle0 sub dup abs 180 gt { 180 add 360 div floor 360 mul sub } { pop } ifelse
% end bug fix
} def
%
/EllipticArcArrow {
  /d ED      % is add or sub
  /b ED      % arrow procedure
  /a1 ED     % angle
  gsave
  newpath
  0 -1000 moveto
  clip                  % Set clippath far from arrow.
  newpath
  0 1 0 0 b             % Draw arrow to determine length.
  grestore
% Length of arrow is on top of stack. Next 3 numbers are junk.
%
  a1 exch ArcAdjust   % Angular position of base of arrow.
  /a2 ED
  pop pop pop
  a2 cos rx mul xOrig add % hv 2007-08-29   x->xOrig
  a2 sin ry mul yOrig add % hv 2007-08-29   y->yOrig
  a1 cos rx mul xOrig add % 
  a1 sin ry mul yOrig add % 
% Now arrow tip coor and base coor are on stack.
  b pop pop pop pop       % Draw arrow, and discard coordinates.
  a2 CLW 8 div
% change value of d (test it by looking if  `` 1 1 d '' gives 2 or not )
  1 1 d 2 eq { /d { sub } def } { /d { add } def } ifelse
  ArcAdjust
% resets original value of d
  1 1 d 2 eq { /d { sub } def } { /d { add } def } ifelse  % Adjust angle to give overlap.
} def
%%------------------ tvz/DG/hv (2004-05-10) end -------------------%%
%
/Rot { CP CP translate 3 -1 roll neg rotate NET  } def
%
/RotBegin { 
  tx@Dict /TMatrix known not { /TMatrix { } def /RAngle { 0 } def } if 
  /TMatrix [ TMatrix CM ] cvx def 
  /a ED 
  a Rot /RAngle [ RAngle dup a add ] cvx def 
} def
%
/RotEnd { 
  /TMatrix [ TMatrix setmatrix ] cvx def 
  /RAngle [ RAngle pop ] cvx def 
} def
%
/PutCoor { gsave CP T CM STV exch exec moveto setmatrix CP grestore } def
/PutBegin { /TMatrix [ TMatrix CM ] cvx def CP 4 2 roll T moveto } def
/PutEnd { CP /TMatrix [ TMatrix setmatrix ] cvx def moveto } def
%
/Uput { 
  /a ED 
  add 2 div /h ED 2 
  div /w ED 
  /s a sin def 
  /c a cos def 
  /b s abs c abs 2 copy gt dup 
    /q ED 
    { pop } { exch pop } ifelse def 
  /w1 c b div w mul def 
  /h1 s b div h mul def 
  q { w1 abs w sub dup c mul abs }{ h1 abs h sub dup s mul abs } ifelse 
} def
%
/UUput { 
  /z ED 
  abs /y ED 
  /x ED 
  q { x s div c mul abs y gt }{ x c div s mul abs y gt } ifelse 
    { x x mul y y mul sub z z mul add sqrt z add } 
    { q { x s div } { x c div } ifelse abs 
    } ifelse 
  a PtoC 
  h1 add exch 
  w1 add exch 
} def
%
/BeginOL { 
  dup (all) eq exch TheOL eq or 
    { IfVisible not { Visible /IfVisible true def } if } 
    { IfVisible { Invisible /IfVisible false def } if } ifelse 
} def
%
/InitOL { 
  /OLUnit [ 3000 3000 matrix defaultmatrix dtransform ] cvx def
  /Visible { CP OLUnit idtransform T moveto } def 
  /Invisible { CP OLUnit neg exch neg exch idtransform T moveto } def 
  /BOL { BeginOL } def
  /IfVisible true def 
} def
%
%%%%%%%%%%%%%%%%% tools %%%%%%%%%%%%%%%%%%%%%%%%%
%%%%% ### bubblesort ###
%% syntax : array bubblesort --> array2 trie par ordre croissant
%% code de Bill Casselman
%% http://www.math.ubc.ca/people/faculty/cass/graphics/text/www/
/bubblesort {
4 dict begin
   /a exch def
   /n a length 1 sub def
   n 0 gt {
      % at this point only the n+1 items in the bottom of a remain to
      % the sorted largest item in that blocks is to be moved up into
      % position n
      n {
         0 1 n 1 sub {
            /i exch def
            a i get a i 1 add get gt {
               % if a[i] > a[i+1] swap a[i] and a[i+1]
               a i 1 add
               a i get
               a i a i 1 add get
               % set new a[i] = old a[i+1]
               put
               % set new a[i+1] = old a[i]
               put
            } if
         } for
         /n n 1 sub def
      } repeat
   } if
   a
end
} def
%
%
/concatstringarray{  %  [(a) (b) ... (z)] --> (ab...z)  20100422
  0 1 index { length add } forall 
  string     
  0 3 2 roll      
  { 3 copy putinterval length add }forall 
  pop  
} bind def
%
/dot2comma {% on stack a string (...) 
  2 dict begin
  /Output exch def
  0 1 Output length 1 sub { 
    /Index exch def 
    Output Index get 46 eq { Output Index 44 put } if 
  } for
  Output
  end
} def
%
end
%-----------------------------------------------------------------------------%
%
% END pstricks.pro

%%EndProcSet
%%BeginProcSet: pst-algparser.pro 0 0
% $Id: pst-algparser.pro 594 2011-10-31 18:13:18Z herbert $
%%
%% PostScript prologue for PSTricks algorithm parser
%% Version 0.04, 2011/10/21
%%
%% This program can be redistributed and/or modified under the terms
%% of the LaTeX Project Public License Distributed from CTAN archives
%% in directory macros/latex/base/lppl.txt.
%%
%%-----------------------------------------------------------------------------%
%
/AlgParser { tx@AlgToPs begin AlgToPs end } def  % Dominique Rodriguez
%
/tx@CoreAnalyzerDict 100 dict def tx@CoreAnalyzerDict begin
%
% PS ANALYZER FOR ALGEBRAIC EXPRESSION V1.13
%
% 09/2011 DR factorial with ! added
%
% E->T|E+T
% T->FS|T*FS
% FS -> F | +FS | -FS
% F->P|F^SF|P!
% P->(E)|literal
% literal->number|var|var[E]|func(params)
% params->E|E,param
% number->TOBEFINISHED
%
%% E expression, T term, SF signed factor, F factor, P power
%
%% parser
%
%% str
%
%% C->E<condition_operators>E
%% STR index -> STR index+lenExpr
/AnalyzeCond { AnalyzeExpr ReadCondOp AnalyzeExpr EvalCondOp  } def
%
%% analyze Expression List (separator , or | )
%% STR index -> STR index+lenExpr
%% /AnalyzeListOfE {
%%   { NextNonBlankChar pop AnalyzeExpr%%dup Strlen eq { exit } if NextNonBlankChar
%%     NextNonBlankChar dup 0 eq { pop exit } if
%%     dup 44 ne 1 index 124 ne and { dup 41 ne { PROBLEMCONTACTBILLOU } { pop exit } ifelse } if
%%     pop NextNonBlankChar dup 0 eq { exit } if 124 ne { PROBLEMCONTACTBILLOU } if 1 add NextNonBlankChar 0 eq {toto} if } loop
%%   AnalyzeListOfEPostHook
%% } def
/AnalyzeListOfE {
  /NotFirst false def
  { NextNonBlankChar pop AnalyzeExpr
    NotFirst { EvalListOfExpr } { /NotFirst true def } ifelse
    dup Strlen eq { exit } if NextNonBlankChar
    dup 44 ne 1 index 124 ne and
    { dup 41 ne { PROBLEMCONTACTBILLOU } { pop exit } ifelse }
    if  pop 1 add } loop
  AnalyzeListOfEPostHook
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% E->T|E+T
%% STR index -> STR index+lenExpr
/AnalyzeExpr {
  AnalyzePreHook AnalyzeTerm IsEndingExpr
  { dup 0 ne { 32 eq { NextNonBlankChar } if } { pop } ifelse }
  { { RollOp 1 add NextNonBlankChar pop AnalyzeTerm PreEvalHook EvalAddSub IsEndingExpr { pop exit } if } loop }
  ifelse
  AnalyzePostHook
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% T->FS|T*FS
%% STR index
/AnalyzeTerm {
  AnalyzePreHook AnalyzeSignedFactor IsEndingTerm
  { dup 0 ne { 32 eq { NextNonBlankChar } if } { pop } ifelse }
  { { RollOp 1 add NextNonBlankChar pop AnalyzeSignedFactor PreEvalHook EvalMulDiv IsEndingTerm { pop exit } if} loop }
  ifelse
  AnalyzePostHook
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% FS -> F | +FS | -FS
%% STR index
/AnalyzeSignedFactor {
  AnalyzePreHook 2 copy get dup IsUnaryOp
  { RollOp 1 add NextNonBlankChar pop AnalyzeSignedFactor EvalUnaryOp }
  { pop AnalyzeFactor }
  ifelse AnalyzePostHook
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% F->P|F^P|P!
%% STR index
/AnalyzeFactor {
  AnalyzePreHook AnalyzePower IsEndingFactor
  { dup 0 ne { 32 eq { NextNonBlankChar } if } { pop } ifelse }
  { { dup 33 eq%% is there a ! DR 09/2011
      { pop 1 add NextNonBlankChar pop EvalFactorial }
      { RollOp 1 add NextNonBlankChar pop AnalyzePower PreEvalHook EvalPower }
      ifelse
      IsEndingFactor { pop exit } if } loop }
  ifelse  AnalyzePostHook
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% P->(E)|literal
%% STR index
/AnalyzePower {
  %% depending of first char either a number, or a literal
  2 copy get dup 40 eq%%an open par
  { pop 1 add NextNonBlankChar pop AnalyzeExpr 1 add NextNonBlankChar pop }
  { AnalyzeLiteral }
  ifelse
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% STR index STR[index] -> STR index
%/AnalyzeLiteral { IsNumber { EvalNumber } { EvalLiteral } ifelse } def
/AnalyzeLiteral { dup IsUnaryOp exch IsNumber or { EvalNumber } { EvalLiteral } ifelse } def%%dr 09102006
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% recognize + or -
%% chr -> T/F
/IsUnaryOp { dup 43 eq exch 45 eq or } bind def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% a number can contain only : 0123456789.
%% chr -> T/F
/IsNumber { dup 48 ge exch dup 57 le 3 -1 roll and exch 46 eq or } bind def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% STR index -> STR index number
%% a number can be of the form [0-9]*.[0-9]*\([eE][+-]?[0-9]+\)?
%% STR index -> STR index' number
/ReadNumber {
  exch dup 3 -1 roll dup 3 1 roll
  %%read mantissa
  { 1 add  2 copy dup Strlen eq { pop pop 0 exit } if get dup IsNumber not { exit } if pop } loop
  dup 101 eq exch 69 eq or
  %%% there is a "e" or "E" -> read exponant
  { 1 add 2 copy get dup IsUnaryOp
    { pop 1 add 2 copy get } if
    { IsNumber not { exit } if 1 add 2 copy get } loop }
  if
  dup 4 1 roll
  3 -1 roll exch 1 index sub getinterval
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% a number can contain only : 0123456789.
%% chr -> T/F
/IsCondOp { dup 30 eq exch dup 60 ge exch 62 le and or } bind def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% STR index -> STR index number
%% a number can be of the form [0-9]*.[0-9]*\([eE][+-]?[0-9]+\)?
%% STR index -> STR index' number
/ReadCondOp {
  NextNonBlankChar 1 index 4 1 roll
  { IsCondOp not { exit } if 1 add  2 copy get } loop
  2 copy 5 -1 roll
  exch 1 index sub getinterval 3 1 roll
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% a literal can contain only : 0123456789.
%% chr -> T/F
/IsLiteral {%
  dup 48 ge exch dup  57 le 3 -1 roll and exch
  dup 65 ge exch dup  90 le 3 -1 roll and 3 -1 roll or exch
  dup 97 ge exch     122 le and or } bind def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% a literal can be of the form [a-zA-Z][a-zA-Z0-9]*\(\((Expression)\)|\(\[Expression\]\)\)?
%% STR index -> literal STR index' nextchr
/ReadLiteral {
  exch dup 3 -1 roll dup 3 1 roll
  %%read literal core
  { 2 copy dup Strlen eq { pop pop 0 exit } if get dup IsLiteral not { exit } if pop 1 add } loop
  4 1 roll dup 5 1 roll 3 -1 roll exch 1 index sub getinterval 4 1 roll
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% expr is ended by end of str or a clpar
%% STR index -> STR index STR[index] T/F
/IsEndingExpr {%
  2 copy dup Strlen eq
  %% if end of str is reached -> end !
  { pop pop 0 true }
  %% ending chr -> clpar, comma, |, <, >, =, !,
  {get dup  dup  41 eq
       exch dup 124 eq
       exch dup  93 eq
       exch dup  44 eq
       exch dup  30 eq
       exch dup  60 ge exch 62 le and or or or or or}
  ifelse } def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% expr is ended by end of str or a +-
%% STR index -> STR index STR[index] T/F
/IsEndingTerm { IsEndingExpr { true } { dup dup 43 eq exch 45 eq or } ifelse } def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% expr is ended by end of str or */
%% STR index -> STR index STR[index] T/F
/IsEndingFactor { IsEndingTerm { true } { dup dup 42 eq exch 47 eq or } ifelse } def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% expr is ended by end of str or ^
%% STR index -> STR index STR[index] T/F
/IsEndingPower { IsEndingFactor { true } { dup 94 eq } ifelse } def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% STR index -> STR index STR[index]
/NextNonBlankChar { { dup Strlen eq { 0 exit } if 2 copy get dup neBlkChar { exit } if pop 1 add } loop } bind def
/neBlkChar { dup 32 ne exch dup 10 ne exch 9 ne and and } bind def
%%%%%%%%%%%%%%%%%%%%%%%%
%% DEBUG
/BRK {false} def
/BRKtrue {/BRK true def} def
/BRKStop {BRK {BRKtoto} if } def
/BRKEvalStop {BRK exch if } def
/BRKBRK2true {BRK {BRK2true} if } def
/BRK2 {false} def
/BRK2true {/BRK2 true def} def
/BRK2Stop {BRK2 {BRK2toto} if } def/BRK {false} def
end
%
%-------------------------------------------------------------------------------%
%
/tx@AlgToPs 12 dict def tx@AlgToPs begin
%
%% algExpr -> PSVector
/AlgToPs { tx@CoreAnalyzerDict begin InitParser AnalyzeListOfE pop pop EndingSequence end } def
/EndingSequence { ExpressionVector aload length /end cvx exch 1 add array astore } def
/InitParser { /ExpressionVector [ /tx@AddMathFunc cvx /begin cvx ] def dup length /Strlen exch def 0 } def
/Strlen 0 def
/EvalListOfExpr {} def%
/EvalNumber {%
    ReadNumber  cvr /ExpressionVector ExpressionVector aload length dup 3 add -1 roll cvx
    exch 1 add array astore def NextNonBlankChar pop } def
/EvalAddSub {%
  /ExpressionVector ExpressionVector aload length dup 5 add -1 roll
  43 eq { /add } { /sub } ifelse cvx exch 1 add array astore def
} def
/EvalMulDiv {%
  /ExpressionVector ExpressionVector aload length dup 5 add -1 roll
  42 eq { /mul } { /div } ifelse cvx exch 1 add array astore def
} def
/EvalPower {%
  /ExpressionVector ExpressionVector aload length dup 5 add -1 roll
  pop /exp cvx exch 1 add array astore def
} def
/EvalFactorial {% DR 09/2011
  /ExpressionVector ExpressionVector aload length
  /fact cvx exch 1 add array astore def
} def
/EvalLiteral {%
  ReadLiteral
  dup 40 eq%%% there is an open par -> function call
  { pop 2 index
    dup (Sum) eq { EvalSum }
    { dup (IfTE) eq { EvalCond }
      { dup (Derive) eq { pop EvalDerive }
	{ pop 1 add NextNonBlankChar pop AnalyzeListOfE 2 index TrigoFunc
          /ExpressionVector ExpressionVector aload length dup 5 add -1 roll cvn cvx
	  exch 1 add array astore def 1 add NextNonBlankChar pop } ifelse } ifelse} ifelse }
  { /ExpressionVector ExpressionVector aload length dup 6 add -1 roll cvn cvx exch 1 add array astore def
    dup 91 eq%%% there is an open bracket -> vector element
    { pop 1 add NextNonBlankChar pop AnalyzeExpr
      /ExpressionVector ExpressionVector aload length /cvi cvx exch /get cvx exch 2 add array astore def 1 add }
    { pop NextNonBlankChar pop }
    ifelse}
  ifelse
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% the derive function : Derive(n,f(x))
%% firstparindex lastparindex ->
/EvalDerive {
  %% manage the function descripiton
  1 add ReadNumber 3 1 roll NextNonBlankChar
  44 ne { ANALYZER_ERROR_missing_second_comma_in_Sum } if
  1 add NextNonBlankChar pop
  3 -1 roll cvi
  dup 0 eq
  { pop AnalyzeExpr 3 -1 roll pop 1 add }
  { 1 sub 3 1 roll (x)  exch tx@Derive begin DeriveIndexed end 4 -1 roll
    { (x) tx@Derive begin Derive end } repeat
    ExpressionVector exch /ExpressionVector [] def
    AlgToPs aload length
    /ExpressionVector 1 index 3 add -1 roll aload length dup 3 add -1 roll  /l2 exch def /l1 exch def
    l1 l2 add 1 add l2 neg roll l1 l2 add array astore def 3 -1 roll pop 1 add
    1 index length /Strlen exch def } ifelse
} def
/EvalSum {%
  pop 1 add NextNonBlankChar pop
  %% read the variable name
  ReadLiteral pop NextNonBlankChar
  44 ne { ANALYZER_ERROR_missing_first_comma_in_Sum } if
  %% read the initial value
  1 add NextNonBlankChar pop ReadNumber cvi 3 1 roll
  2 copy get 44 ne { ANALYZER_ERROR_missing_second_comma_in_Sum } if
  %% read the increment value
  1 add NextNonBlankChar pop ReadNumber cvi 3 1 roll
  2 copy get 44 ne { ANALYZER_ERROR_missing_second_comma_in_Sum } if
  %% read the limit value
  1 add NextNonBlankChar pop ReadNumber cvi 3 1 roll
  2 copy get 44 ne { ANALYZER_ERROR_missing_second_comma_in_Sum } if
  /ExpressionVector ExpressionVector aload length dup 7 add -3 roll 0 4 1 roll
  5 -1 roll 4 add array astore def
  %% keep ExpressionVector for later and create a new one for internal Sum computation
  ExpressionVector 3 1 roll /ExpressionVector [ 6 -1 roll cvn /exch cvx /def cvx ] def
  1 add NextNonBlankChar pop AnalyzeExpr
  %% add each term
  /ExpressionVector ExpressionVector aload length 1 add /add cvx exch array astore def
  /ExpressionVector 4 -1 roll aload length ExpressionVector cvx /for cvx 3 -1 roll 2 add
  array astore def 3 -1 roll pop 1 add
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Convert to radians if trigo function call
%% (name) ->
/TrigoFunc {
  dup (cos) eq 1 index (sin) eq or exch (tan) eq or
  { /ExpressionVector ExpressionVector aload length Pi /div cvx 180 /mul cvx 5 -1 roll 4 add
    array astore def
  } if
} def
/EvalCond {%
  pop 1 add AnalyzeCond NextNonBlankChar
  44 ne { ANALYZER_ERROR_missing_first_comma_in_IfTE } if
  ExpressionVector 3 1 roll /ExpressionVector [] def
  1 add AnalyzeExpr ExpressionVector 3 1 roll /ExpressionVector [] def
  NextNonBlankChar 44 ne { ANALYZER_ERROR_missing_second_comma_in_IfTE } if
  1 add AnalyzeExpr
  NextNonBlankChar 41 ne { ANALYZER_ERROR_missing_ending parenthesis_in_IfTE } if
  ExpressionVector
  /ExpressionVector 6 -1 roll aload length dup
  6 add -1 roll cvx exch dup 4 add -1 roll cvx /ifelse cvx 3 -1 roll 3 add array astore def
  1 add 3 -1 roll pop
} def
%% CondOp STR index
/EvalCondOp {%
  3 -1 roll
  dup (=) eq  { /eq } {%
  dup (<) eq  { /lt } {%
  dup (>) eq  { /gt } {%
  dup (>=) eq { /ge } {%
  dup (<=) eq { /ge } {%
  dup (!=) eq { /ne } { ERROR_non_valid_conditional_operator }
  ifelse } ifelse } ifelse } ifelse } ifelse } ifelse
  cvx exch pop
  /ExpressionVector ExpressionVector aload length dup 3 add -1 roll exch 1 add array astore def } def
/EvalUnaryOp {
  3 -1 roll 45 eq { /ExpressionVector ExpressionVector aload length /neg cvx exch 1 add array astore def } if
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% H O O K S
/AnalyzePreHook {} bind def
/PreEvalHook {} bind def
/AnalyzeListOfEPostHook {} bind def
/AnalyzePostHook {} def
/RollOp { 3 1 roll } bind def
end   %tx@CoreAnalyzerDict
%
%--------------------------------------------------------------------%
%
/tx@Derive 41 dict def tx@Derive begin
%%increase ^^ for each function added
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% algExpr variable -> PSVector
/Derive {%
  10240 string 3 1 roll 0 3 1 roll
  /Variable exch def
  tx@CoreAnalyzerDict begin InitParser AnalyzeListOfE end
} def
/Strlen 0 def
/InitParser { dup length /Strlen exch def 0 } def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% algExpr variable index -> PSVector
/DeriveIndexed {%
  3 1 roll 10240 string 3 1 roll 0 3 1 roll
  /Variable exch def
  tx@CoreAnalyzerDict begin InitParser pop 4 -1 roll AnalyzeExpr 4 -2 roll pop pop 4 -2 roll exch pop end
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% (u,v)'=-(u',v')
/EvalListOfExpr {%
  4 2 roll 2 copy 9 -1 roll dup length 4 1 roll putinterval add AddPipe
           2 copy 7 -1 roll dup length 4 1 roll putinterval add
  6 -2 roll pop pop
  2 copy pop 0 6 2 roll GetIntervalNewStr 5 1 roll 2 copy 0 exch getinterval 6 1 roll } def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% (-u)'=-(u')
/EvalUnaryOp {
  4 -2 roll 4 index (0) eq
  { (0) StrConcat 7 -1 roll pop }
  { 7 -1 roll 45 eq
    { AddSub AddOpPar true } { false } ifelse
    3 1 roll 5 index StrConcat 3 -1 roll { AddClPar } if } ifelse
  2 copy pop 0 6 2 roll GetIntervalNewStr
  7 -2 roll pop pop 2 index 6 index dup 4 index exch sub getinterval exch 6 2 roll
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% (number)'=0
/EvalNumber { ReadNumber (0) 6 2 roll } def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% (u+v)'=u'+v'
/EvalAddSub {%
  7 index dup (0) eq
  { pop true }%% du=0 nothing added
  { dup length exch 5 index 5 index 3 -1 roll putinterval 4 -1 roll add 3 1 roll false }
  ifelse
  5 index dup (0) eq
  { pop { (0) } { 4 -2 roll 2 copy pop 0  6 2 roll GetIntervalNewStr } ifelse }%%dv=0
  { exch
    { 5 -2 roll 7 index 45 eq { AddSub } if false } %%nothing yet added
    { 5 -2 roll 7 index 43 eq%%something yet added
      { AddAdd false } { AddSub AddOpPar true } ifelse }
    ifelse 11 1 roll
    3 -1 roll StrConcat 10 -1 roll { AddClPar } if
    2 copy pop 0 6 2 roll GetIntervalNewStr }
  ifelse
  mark 11 -5 roll cleartomark 2 index 6 index dup 4 index exch sub getinterval exch 6 2 roll
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% (u*v)' or (u/v)'
/EvalMulDiv { 6 index 42 eq {EvalMul} {EvalDiv} ifelse } def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% (u*v)'=u'*v+u*v'
/EvalMul {%
  4 -2 roll 7 index dup (0) eq
  { pop false }%%du=0
  { (1) eq%%du=1
    { false }
    { AddOpPar 7 index StrConcat AddClPar AddMul AddOpPar true } ifelse
    3 1 roll 6 index StrConcat 3 -1 roll { AddClPar } if
    true }%%du!=0
  ifelse
  5 1 roll 5 index (0) eq
  { 5 -1 roll not { (0) StrConcat } if }%%dv=0
  { 5 -1 roll { AddAdd } if
    4 index (1) eq
    { 8 index StrConcat }
    { AddOpPar 8 index StrConcat AddClPar AddMul AddOpPar 4 index StrConcat AddClPar }
    ifelse
  }%%dv!=0
  ifelse
  2 copy pop 0 6 2 roll GetIntervalNewStr
  mark 11 -5 roll cleartomark 2 index 6 index dup 4 index exch sub getinterval exch 6 2 roll
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% (u/v)'=(u'*v-u*v')/v^2
/EvalDiv {%
  4 -2 roll
  4 index (0) eq%%dv=0 -> u'/v
  { 7 index (0) eq { (0) StrConcat } { AddOpPar 7 index StrConcat AddClPar AddDiv 5 index StrConcat } ifelse }
  { 7 index dup (0) eq
    { pop }%%du=0
    { (1) eq%%du=1
      { false }
      { AddOpPar 7 index StrConcat AddClPar AddMul AddOpPar true } ifelse
      3 1 roll 6 index StrConcat 3 -1 roll { AddClPar } if}%%du!=0
    ifelse
      AddSub
      4 index (1) eq
      { 8 index StrConcat }
      { AddOpPar 8 index StrConcat AddClPar AddMul AddOpPar 4 index StrConcat AddClPar }
      ifelse
    %}%%dv!=0
    2 copy GetIntervalNewStr 3 1 roll pop 0 AddOpPar 3 -1 roll StrConcat AddClPar
    AddDiv AddOpPar 5 index StrConcat AddClPar 2 copy (^2) putinterval 2 add }
  ifelse
  2 copy pop 0 6 2 roll GetIntervalNewStr
  mark 11 -5 roll cleartomark 2 index 6 index dup 4 index exch sub getinterval exch 6 2 roll
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% str1 index str2 -> str1 index
/StrConcat { dup length 4 2 roll 2 copy 6 -1 roll putinterval 3 -1 roll add } bind def
/GetIntervalNewStr { 0 exch getinterval dup length string copy } bind def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% (u^v)'=(u^v)'=u'vu^(v-1)+v'u^(v)ln(u)
/EvalPower {%
  4 -2 roll 7 index (0) eq
  {%%if du=0 then (u^v)'=v'ln(u)u^v
    4 index (0) eq
    { (0) StrConcat }%%if dv=0 then (u^v)'=0
    { 4 index (1) ne { AddOpPar 4 index StrConcat (\)*) StrConcat } if
      8 index (e) ne { (ln\() StrConcat 8 index StrConcat (\)*) StrConcat } if
      AddOpPar 8 index StrConcat (\)^\() StrConcat 5 index StrConcat AddClPar } ifelse
  }
  {%%du!=0
    4 index (0) eq
    {%%if dv=0 then (u^v)'=vu'u^(v-1)
      5 index dup IsStrNumber
      { dup (0) eq
        { StrConcat }
        { dup dup (1) eq exch (1.0) eq or
          { StrConcat  }
	  { StrConcat
	    7 index dup (1) ne exch (1.0) ne and%%%dr 09102006 insert du if <> 1
	    { (*\() StrConcat 7 index StrConcat (\)) StrConcat } if%%%dr 09102006
            (*\() StrConcat 8 index StrConcat (\)) StrConcat
            5 index  dup dup (2) eq exch (2.0) eq or
	    { pop } { cvr 1 sub 20 string cvs 3 1 roll (^) StrConcat 3 -1 roll StrConcat } ifelse } ifelse } ifelse }
      { pop AddOpPar 5 index StrConcat (\)*\() StrConcat 8 index StrConcat (\)^\() StrConcat
        5 index StrConcat (-1\)) StrConcat } ifelse
    }
    {%%if dv!=0 and du!=0 then (u^v)'=u'vu^(v-1)+v'u^(v)ln(u)
      7 index (1) ne { AddOpPar 7 index StrConcat (\)*) StrConcat } if
      AddOpPar 5 index StrConcat (\)*\() StrConcat
      8 index StrConcat (\)^\() StrConcat
      5 index StrConcat (-1\)+\() StrConcat
      4 index (1) ne { 4 index StrConcat (\)*\() StrConcat } if
      8 index StrConcat (\)^\() StrConcat
      5 index StrConcat (\)*ln\() StrConcat
      8 index StrConcat AddClPar
    } ifelse
  } ifelse
  2 copy pop 0 6 2 roll GetIntervalNewStr
  mark 11 -5 roll cleartomark 2 index 6 index dup 4 index exch sub getinterval exch 6 2 roll
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% No derivative for factorial ! only cst => null derivative
/EvalFactorial {% DR 09/2011
  4 index (0) eq
  { (0) mark 8 -2 roll  cleartomark 2 index 7 index dup 4 index exch sub getinterval exch 6 2 roll }
  { DERIVATIVE_ENGINE_ERROR_no_variable_in_factorial } ifelse
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% str -> true/false
/IsStrNumber {%
  true exch
  { dup 48 lt exch dup 57 gt 3 -1 roll or
    exch dup 46 ne%%.
    exch dup 43 ne%%+
    exch 45 ne%%-
    and and and { pop false } if } forall
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% literal switch -> func call, vector, variables
/EvalLiteral {%
  ReadLiteral dup 40 eq%%% there is an open par -> function call
  { pop (EvalFunc_             ) 9 4 index StrConcat 0 exch getinterval cvn cvx exec }
  { dup 91 eq%%% there is an open bracket -> vector element
    { DERIVATIVE_ENGINE_ERROR_vector_not_yet_implemented }
    { pop EvalVariable }
    ifelse }
  ifelse
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% first last parpos Expr[first:parpos-1] ->
/EvalVariable { 2 index Variable eq { (1) } { (0) } ifelse 4 -1 roll exch 6 2 roll } def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% (f(u))'=u'f'(u)
/EvalFunc {
  4 2 roll 4 index (1) ne
  { AddOpPar 4 index StrConcat (\)*) StrConcat } if
  (Eval             ) 4 8 index StrConcat 0 exch getinterval cvn cvx exec
  2 copy pop 0 6 2 roll GetIntervalNewStr
  mark 9 -3 roll cleartomark 2 index 6 index dup 4 index exch sub getinterval exch 6 2 roll
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Func derivative -> Eval<func>
/EvalFunc_sin {%
  PreCommonFunc
  { (cos\() StrConcat 5 index StrConcat AddClPar } if
  PostCommonFunc } def
/EvalFunc_cos {%
  PreCommonFunc
  { (\(-sin\() StrConcat 5 index StrConcat (\)\)) StrConcat } if
  PostCommonFunc } def
/EvalFunc_tan {%
  PreCommonFunc
  {  dup 0 eq { (1) StrConcat } { 1 sub } ifelse  (/cos\() StrConcat 5 index StrConcat (\)^2) StrConcat } if
  PostCommonFunc } def
/EvalFunc_asin {%
  PreCommonFunc
  { (1/sqrt\(1-\() StrConcat 5 index StrConcat (\)^2\)\)) StrConcat } if
  PostCommonFunc } def
/EvalFunc_acos {%
  PreCommonFunc
  { (-1/sqrt\(1-\() StrConcat 5 index StrConcat (\)^2\)\)) StrConcat } if
  PostCommonFunc } def
/EvalFunc_atg {%
  PreCommonFunc
  { (1/\(1+\() StrConcat 5 index StrConcat (\)^2\)\)) StrConcat } if
  PostCommonFunc } def
/EvalFunc_ln {%
  PreCommonFunc
  {  dup 0 eq { (1) StrConcat } { 1 sub } ifelse (/\() StrConcat 5 index StrConcat AddClPar } if
  PostCommonFunc } def
/EvalFunc_exp {%
  PreCommonFunc
  {  (exp\() StrConcat 5 index StrConcat AddClPar } if
  PostCommonFunc } def
/EvalFunc_EXP {%
  PreCommonFunc
  {  (EXP\() StrConcat 5 index StrConcat AddClPar } if
  PostCommonFunc } def
/EvalFunc_sqrt {%
  PreCommonFunc
  { dup 0 eq { (1) StrConcat } { 1 sub } ifelse (/\(2*sqrt\() StrConcat 5 index StrConcat (\)\)) StrConcat } if
  PostCommonFunc } def
/EvalFunc_Fact {%
  PreCommonFunc { DERIVATIVE_ENGINE_ERROR_no_variable_expression_in_Fact } if
  PostCommonFunc } def
/EvalFunc_sh {%
  PreCommonFunc
  { (ch\() StrConcat 5 index StrConcat AddClPar } if
  PostCommonFunc } def
/EvalFunc_ch {%
  PreCommonFunc
  { (sh\() StrConcat 5 index StrConcat AddClPar } if
  PostCommonFunc } def
/EvalFunc_th {%
  PreCommonFunc
  {  dup 0 eq { (1) StrConcat } { 1 sub } ifelse  (/ch\() StrConcat 5 index StrConcat (\)^2) StrConcat } if
  PostCommonFunc } def
/EvalFunc_Argsh {%
  PreCommonFunc
  { (1/sqrt\(1+\() StrConcat 5 index StrConcat (\)^2\)\)) StrConcat } if
  PostCommonFunc } def
/EvalFunc_Argch {%
  PreCommonFunc
  { (1/sqrt\(\() StrConcat 5 index StrConcat (\)^2-1\)\)) StrConcat } if
  PostCommonFunc } def
/EvalFunc_Argth {%
  PreCommonFunc
  { (1/\(1-\() StrConcat 5 index StrConcat (\)^2\)\)) StrConcat } if
  PostCommonFunc } def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
/PreCommonFunc {
  1 add NextNonBlankChar pop 3 -1 roll 5 1 roll AnalyzeExpr 1 add NextNonBlankChar pop
  4 2 roll 4 index (0) eq
  { (0) StrConcat false }
  { 4 index (1)  ne { AddOpPar 4 index StrConcat (\)*) StrConcat } if true } ifelse
} def
/PostCommonFunc {
  2 copy pop 0 6 2 roll GetIntervalNewStr
  mark 9 -3 roll cleartomark 2 index 6 index dup 4 index exch sub getinterval exch 6 2 roll
} def
/EvalFunc_Derive {%
  1 add ReadNumber cvi 1 add dup cvr log 1 add cvi string cvs
  4 -1 roll pop 5 1 roll 1 add NextNonBlankChar pop AnalyzeExpr 1 add
  4 -2 roll (Derive\() StrConcat 7 -1 roll StrConcat (,) StrConcat 6 -1 roll StrConcat AddClPar
  2 copy pop 0 6 2 roll GetIntervalNewStr 6 -1 roll pop 2 index 6 index dup 4 index exch sub getinterval
  exch 6 2 roll } def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% literal switch -> func call, vector, variables
/EvalFunc_Sum {%
  1 add NextNonBlankChar pop
  %% read the variable name
  ReadLiteral pop 3 -1 roll pop NextNonBlankChar
  44 ne { ANALYZER_ERROR_missing_first_comma_in_Sum } if
  %% read the initial value
  1 add NextNonBlankChar pop ReadNumber pop
  2 copy get 44 ne { ANALYZER_ERROR_missing_second_comma_in_Sum } if
  %% read the increment value
  1 add NextNonBlankChar pop ReadNumber pop
  2 copy get 44 ne { ANALYZER_ERROR_missing_third_comma_in_Sum } if
  %% read the limit value
  1 add NextNonBlankChar pop ReadNumber pop
  2 copy get 44 ne { ANALYZER_ERROR_missing_fourth_comma_in_Sum } if
  1 add NextNonBlankChar pop dup 6 1 roll 3 -1 roll pop AnalyzeExpr 1 add NextNonBlankChar pop
  4 -2 roll 3 index 8 index dup 9 index exch sub getinterval StrConcat
  4 index StrConcat AddClPar
  2 copy pop 0 6 2 roll GetIntervalNewStr
  mark 9 -3 roll cleartomark 2 index 6 index dup 4 index exch sub getinterval exch 6 2 roll
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% literal switch -> func call, vector, variables
/EvalFunc_IfTE {%
  3 -1 roll pop 1 add NextNonBlankChar pop SkipCond
  NextNonBlankChar
  44 ne { ANALYZER_ERROR_missing_first_comma_in_IfTE } if
  1 add NextNonBlankChar pop dup 5 1 roll
  AnalyzeExpr NextNonBlankChar
  44 ne { ANALYZER_ERROR_missing_second_comma_in_IfTE } if
  1 add NextNonBlankChar pop
  AnalyzeExpr 1 add NextNonBlankChar pop
  4 -2 roll 3 index 10 index dup 11 index exch sub getinterval StrConcat
  6 index StrConcat (,) StrConcat 4 index StrConcat AddClPar
  2 copy pop 0 6 2 roll GetIntervalNewStr
  mark 11 -5 roll cleartomark 2 index 6 index dup 4 index exch sub getinterval exch 6 2 roll
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% advance in str until a comma is found (no error detection!)
%% str index -> str index'
/SkipCond { { 1 add 2 copy get 44 eq {exit } if } loop } bind def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Convert to radians if trigo function call
%% (name) ->
/TrigoFunc {
  dup (cos) eq 1 index (sin) eq or exch (tan) eq or
  { /ExpressionVector ExpressionVector aload length Pi /div cvx 180 /mul cvx 5 -1 roll 4 add
    array astore def
  } if
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% No derivative for condition....
/EvalCondOp { 3 -1 roll pop } bind def
/PutIntervalOneAdd {putinterval 1 add} bind def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Add open parenthesis in string at the given index
%% str index -> str index+1
/AddOpPar {2 copy (\() PutIntervalOneAdd} bind def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Add close parenthesis in string at the given index
%% str index -> str index+1
/AddClPar {2 copy (\)) PutIntervalOneAdd} bind def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Add 0 in string at the given index
%% str index -> str index+1
/AddZero {2 copy (0) PutIntervalOneAdd} bind def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Add open parenthesis in string at the given index
%% str index -> str index+1
/AddMul {2 copy (*) PutIntervalOneAdd} bind def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Add open parenthesis in string at the given index
%% str index -> str index+1
/AddDiv {2 copy (/) PutIntervalOneAdd} bind def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Add a plus sign in string at the given index
%% str index -> str index+1
/AddAdd {2 copy (+) PutIntervalOneAdd} bind def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Add a minus sign in string at the given index
%% str index -> str index+1
/AddSub {2 copy (-) PutIntervalOneAdd} bind def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Add a pipe sign in string at the given index
%% str index -> str index+1
/AddPipe {2 copy (|) PutIntervalOneAdd} bind def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% H O O K S
/AnalyzePreHook { dup 5 1 roll } bind def
/PreEvalHook {} def
/AnalyzePostHook { 7 -1 roll pop } bind def
/AnalyzeListOfEPostHook { 6 -1 roll mark 6 1 roll cleartomark } bind def
/RollOp { 5 1 roll } bind def
end%%%tx@CoreAnalyzerDict
/tx@AddMathFunc 12 dict def tx@AddMathFunc begin
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% NEW FUNC
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% function arcsine in radians asin(x)=atan(x/sqrt(1-x^2))
%% x -> theta
/asin {%
  dup abs 1 gt { EQDFasinrangeerror  } if
  dup dup dup mul 1 exch sub sqrt atan exch 0 lt { 360 sub } if DegtoRad
} def
%% function arccosine in radians acos(x)=atan(sqrt(1-x^2)/x)
%% x -> theta
/acos {%
  dup abs 1 gt { EQDFacosrangeerror  } if
  dup dup mul 1 exch sub sqrt exch atan DegtoRad
} def
%% function arctangent in radians
%% x -> theta
/atg { 1 atan dup 90 gt { 360 sub } if DegtoRad } bind def
%% HYPERBOLIC FUNCTIONS
/sh { dup Ex exch neg Ex sub 2 div } def
/ch { dup Ex exch neg Ex add 2 div } def
/th { dup sh exch ch div } def
/Argsh { dup dup mul 1 add sqrt add ln } def
/Argch { dup dup mul 1 sub sqrt add ln } def
/Argth { dup 1 add exch 1 exch sub div ln 2 div } def
%% modified exponential funtion for 0
%% x n -> x^n
/Exp { dup 0 eq { pop pop 1 } { exp } ifelse } bind def
%% modified exponential funtion for 0
%% x -> e^x
/Ex { Euler exch exp } bind def
%%
%% factorial function
%% n -> n!
/Fact { 1 exch 2 exch 1 exch { mul } for } bind def
/fact { Fact } bind def
/! { Fact } bind def
end
%
% END pst-algparser.pro

%%EndProcSet
%%BeginProcSet: pst-tools.pro 0 0
% $Id: pst-tools.pro 622 2012-01-01 15:36:14Z herbert $
%
%% PostScript tools prologue for pstricks.tex.
%% Version 0.02, 2012/01/01
%%
%% This program can be redistributed and/or modified under the terms
%% of the LaTeX Project Public License Distributed from CTAN archives
%% in directory macros/latex/base/lppl.txt.
%
%
/Pi2 1.57079632679489661925640 def
/factorial { % n on stack, returns n! 
  dup 0 eq { 1 }{ 
    dup 1 gt { dup 1 sub factorial mul } if }
  ifelse } def 
%
/MoverN { % m n on stack, returns the binomial coefficient m over n
  2 dict begin
  /n exch def /m exch def
  n 0 eq { 1 }{
    m n eq { 1 }{
      m factorial n factorial m n sub factorial mul div } ifelse } ifelse 
  end
} def
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% subroutines for complex numbers, given as an array [a b] 
% which is a+bi = Real+i Imag
%
/cxadd {		% [a1 b1] [a2 b2] = [a1+a2 b1+b2]
  dup 0 get		% [a1 b1] [a2 b2] a2
  3 -1 roll		% [a2 b2] a2 [a1 b1]
  dup 0 get		% [a2 b2] a2 [a1 b1] a1
  3 -1 roll		% [a2 b2] [a1 b1] a1 a2
  add			% [a2 b2] [a1 b1] a1+a2
  3 1 roll		% a1+a2 [a2 b2] [a1 b1]
  1 get			% a1+a2 [a2 b2] b1
  exch 1 get		% a1+a2 b1 b2
  add 2 array astore
} def
%
/cxneg {		% [a b]
  dup 1 get		% [a b] b
  exch 0 get		% b a
  neg exch neg		% -a -b
  2 array astore
} def
%
/cxsub { cxneg cxadd } def  % same as negative addition
%
% [a1 b1][a2 b2] = [a1a2-b1b2 a1b2+b1a2] = [a3 b3]
/cxmul {		% [a1 b1] [a2 b2]
  dup 0 get		% [a1 b1] [a2 b2] a2
  exch 1 get		% [a1 b1] a2 b2
  3 -1 roll		% a2 b2 [a1 b1]
  dup 0 get		% a2 b2 [a1 b1] a1
  exch 1 get		% a2 b2 a1 b1
  dup			% a2 b2 a1 b1 b1
  5 -1 roll dup		% b2 a1 b1 b1 a2 a2
  3 1 roll mul		% b2 a1 b1 a2 b1a2
  5 -2 roll dup		% b1 a2 b1a2 b2 a1 a1
  3 -1 roll dup		% b1 a2 b1a2 a1 a1 b2 b2
  3 1 roll mul		% b1 a2 b1a2 a1 b2 a1b2
  4 -1 roll add		% b1 a2 a1 b2 b3
  4 2 roll mul		% b1 b2 b3 a1a2
  4 2 roll mul sub	% b3 a3
  exch 2 array astore
} def
%
% [a b]^2 = [a^2-b^2 2ab] = [a2 b2]
/cxsqr {		% [a b]   square root
  dup 0 get exch 1 get	% a b
  dup dup mul		% a b b^2
  3 -1 roll		% b b^2 a
  dup dup mul 		% b b^2 a a^2
  3 -1 roll sub		% b a a2
  3 1 roll mul 2 mul	% a2 b2	
  2 array astore
} def
%
/cxsqrt {		% [a b]
%  dup cxnorm sqrt /r exch def
%  cxarg 2 div RadtoDeg dup cos r mul exch sin r mul cxmake2 
  cxlog 		% log[a b]
  2 cxrdiv 		% log[a b]/2
  aload pop exch	% b a
  2.781 exch exp	% b exp(a)
  exch cxconv exch	% [Re +iIm] exp(a)
  cxrmul		%
} def
%
/cxarg { 		% [a b] 
  aload pop 		% a b
  exch atan 		% arctan b/a
  DegtoRad 		% arg(z)=atan(b/a)
} def
%
% log[a b] = [a^2-b^2 2ab] = [a2 b2]
/cxlog {		% [a b]
  dup 			% [a b][a b]
  cxnorm 		% [a b] |z|
  log 			% [a b] log|z|
  exch 			% log|z|[a b]
  cxarg 		% log|z| Theta
  cxmake2 		% [log|z| Theta]
} def
%
% square of magnitude of complex number
/cxnorm2 {		% [a b]
  dup 0 get exch 1 get	% a b
  dup mul			% a b^2
  exch dup mul add	% a^2+b^2
} def
%
/cxnorm {		% [a b]
  cxnorm2 sqrt
} def
%
/cxconj {		% conjugent complex
  dup 0 get exch 1 get	% a b
  neg 2 array astore	% [a -b]
} def
%
/cxre { 0 get } def	% real value
/cxim { 1 get } def	% imag value
%
% 1/[a b] = ([a -b]/(a^2+b^2)
/cxrecip {		% [a b]
  dup cxnorm2 exch	% n2 [a b]
  dup 0 get exch 1 get	% n2 a b
  3 -1 roll		% a b n2
  dup			% a b n2 n2
  4 -1 roll exch div	% b n2 a/n2
  3 1 roll div		% a/n2 b/n2
  neg 2 array astore
} def
%
/cxmake1 { 0 2 array astore } def % make a complex number, real given
/cxmake2 { 2 array astore } def	  % dito, both given
%
/cxdiv { cxrecip cxmul } def
%
% multiplikation by a real number
/cxrmul {		% [a b] r
  exch aload pop	% r a b
  3 -1 roll dup		% a b r r
  3 1 roll mul		% a r b*r
  3 1 roll mul		% b*r a*r
  exch 2 array astore   % [a*r b*r]
} def
%
% division by a real number
/cxrdiv {		% [a b] r
  1 exch div		% [a b] 1/r
  cxrmul
} def
%
% exp(i theta) = cos(theta)+i sin(theta) polar<->cartesian
/cxconv {		% theta
  RadtoDeg dup sin exch cos cxmake2
} def

%%%%% ### bubblesort ###
%% syntax : array bubblesort --> array2 trie par ordre croissant
%% code de Bill Casselman
%% http://www.math.ubc.ca/people/faculty/cass/graphics/text/www/
/bubblesort { % on stack must be an array [ ... ]
4 dict begin
   /a exch def
   /n a length 1 sub def
   n 0 gt {
      % at this point only the n+1 items in the bottom of a remain to
      % the sorted largest item in that blocks is to be moved up into
      % position n
      n {
         0 1 n 1 sub {
            /i exch def
            a i get a i 1 add get gt {
               % if a[i] > a[i+1] swap a[i] and a[i+1]
               a i 1 add
               a i get
               a i a i 1 add get
               % set new a[i] = old a[i+1]
               put
               % set new a[i+1] = old a[i]
               put
            } if
         } for
         /n n 1 sub def
      } repeat
   } if
   a % return the sorted array
end
} def
%
/concatstringarray{  %  [(a) (b) ... (z)] --> (ab...z)  20100422
  0 1 index { length add } forall 
  string     
  0 3 2 roll      
  { 3 copy putinterval length add }forall 
  pop  
} bind def
%
/dot2comma {% on stack a string (...) 
  2 dict begin
  /Output exch def
  0 1 Output length 1 sub { 
    /Index exch def 
    Output Index get 46 eq { Output Index 44 put } if 
  } for
  Output
  end
} def
%
%-----------------------------------------------------------------------------%
% END pst-tools.pro

%%EndProcSet
%%BeginProcSet: pst-dots.pro 0 0
% $Id: pst-dots.pro 130 2009-08-27 08:55:03Z herbert $
%
%% PostScript prologue for pstricks.tex.
%% Version 2.02,  2009/06/16
%%
%% For distribution, see pstricks.tex.
%%
%% Timothy Van Zandt <tvz@Princeton.EDU>
%%
%% This program can be redistributed and/or modified under the terms
%% of the LaTeX Project Public License Distributed from CTAN archives
%% in directory macros/latex/base/lppl.txt.
%%
%% Modified by Etienne Riga  - Dec. 16, 1999
%% Modified by Etienne Riga  - 2005/01/01 (er)
%% to add /Diamond, /SolidDiamond and /BoldDiamond
%% Modified by Herbert Voss (hv) - 2008/04/17 
%
10 dict dup begin			% hold local
  /FontType 3 def
  /FontMatrix [.001 0 0 .001 0 0] def
%  /FontBBox [-571.5 -742.5 571.5 742.5] def % changed to next line 20060616 hv
  /FontBBox [-1000 -1000 1000 1000] def  % See end of file in /BuildGlyph
  /Encoding 256 array def
  0 1 255 {Encoding exch /.notdef put} for % fill the array with /.notdef
  Encoding				   % replace with given dot names
    dup (b) 0 get /Bullet put		   % get the numerical position of b in ASCII
%					   % and save /Bullet at this place in Encoding 
    dup (c) 0 get /Circle put
    dup (C) 0 get /BoldCircle put	% 67
    dup (u) 0 get /SolidTriangle put
    dup (t) 0 get /Triangle put
    dup (T) 0 get /BoldTriangle put
    dup (r) 0 get /SolidSquare put
    dup (s) 0 get /Square put
    dup (S) 0 get /BoldSquare put
    dup (q) 0 get /SolidPentagon put
    dup (p) 0 get /Pentagon put
    dup (P) 0 get /BoldPentagon put
%%%		  
    dup (k) 0 get /Asterisk put
    dup (K) 0 get /BoldAsterisk put
    dup (J) 0 get /SolidAsterisk put
    dup (h) 0 get /Hexagon put
    dup (H) 0 get /BoldHexagon put
    dup (G) 0 get /SolidHexagon put
    dup (f) 0 get /Octogon put		% 2008-04-18 hv
    dup (F) 0 get /BoldOctogon put	% 2008-04-18 hv
    dup (g) 0 get /SolidOctogon put	% 2008-04-18 hv
    dup (a) 0 get /Add put
    dup (A) 0 get /BoldAdd put 		% 65
    dup (x) 0 get /Mul put
    dup (X) 0 get /BoldMul put
    dup (m) 0 get /Oplus put
    dup (M) 0 get /BOplus put
    dup (e) 0 get /SolidOplus put
    dup (n) 0 get /Otimes put
    dup (N) 0 get /BOtimes put
    dup (E) 0 get /SolidOtimes put
    dup (i) 0 get /Bar put
    dup (I) 0 get /BoldBar put
    dup (l) 0 get /SolidDiamond put
    dup (d) 0 get /Diamond put
        (D) 0 get /BoldDiamond put
%%%  
/CharProcs 47 dict def
CharProcs begin
  /CirclePath {0 0 500 0 360 arc closepath} def
  /Bullet {CirclePath fill} def
  /Circle {CirclePath .9 .9 scale CirclePath eofill} def
  /BoldCircle {CirclePath .8 .8 scale CirclePath eofill} def
  /TrianglePath {0 660 moveto -571.5 -330 lineto 571.5 -330 lineto closepath} def
  /SolidTriangle {TrianglePath fill} def
  /Triangle {TrianglePath .85 .85 scale TrianglePath eofill} def
  /BoldTriangle {TrianglePath .7 .7 scale TrianglePath eofill} def
  /SquarePath {-450 450 moveto 450 450 lineto 450 -450 lineto -450 -450 lineto closepath} def
  /SolidSquare {SquarePath fill} def
  /Square {SquarePath .89 .89 scale SquarePath eofill} def
  /BoldSquare {SquarePath .78 .78 scale SquarePath eofill} def
  /PentagonPath {
    -337.8 -465 moveto 337.8 -465 lineto 546.6 177.6 lineto
    0 574.7 lineto -546.6 177.6 lineto closepath
  } def
  /SolidPentagon {PentagonPath fill} def
  /Pentagon {PentagonPath .89 .89 scale PentagonPath eofill} def
  /BoldPentagon {PentagonPath .78 .78 scale PentagonPath eofill} def
%-------------- hv begin 2004/07/25   from: er 2003/03/24
  /HexagonPath {
    0 550 moveto -476 275 lineto -476 -275 lineto
    0 -550 lineto 476 -275 lineto 476 275 lineto closepath
  } def
  /SolidHexagon {HexagonPath fill} def
  /Hexagon {HexagonPath .89 .89 scale HexagonPath eofill} def
  /BoldHexagon {HexagonPath .79 .79 scale HexagonPath eofill} def
%					2008-04-18 hv
  /OctogonPath { 
     550 dup 22.5 tan mul dup neg dup add /xMove exch def 
     exch moveto 7 { xMove 0 rlineto 45 rotate } repeat closepath } def 
  /SolidOctogon { OctogonPath fill                             } def
  /Octogon {      OctogonPath .89 .89 scale OctogonPath eofill } def
  /BoldOctogon {  OctogonPath .79 .79 scale OctogonPath eofill } def
%
  /AsteriskPath {
    20 0 moveto 10 250 180 500 0 500 curveto
    -180 500 -10 250 -20 0 curveto closepath
  } def
  /Asterisk {
    AsteriskPath 60 rotate AsteriskPath 60 rotate AsteriskPath
    60 rotate AsteriskPath 60 rotate AsteriskPath 60 rotate AsteriskPath fill
  } def
%
  /Basterp {50 250 220 500 0 500 curveto -220 500 -50 250 -50 30 cos 100 mul curveto} def
  /BoldAsteriskPath {
    50 30 cos 100 mul moveto  Basterp
    60 rotate Basterp 60 rotate Basterp
    60 rotate Basterp 60 rotate Basterp
    60 rotate Basterp closepath
  } def
  /BoldAsterisk {BoldAsteriskPath fill} def
  /SolidAsterisk {CirclePath .9 .9 scale BoldAsteriskPath eofill} def
  /CrossPath {
    40 550 moveto -40 550 lineto -40 40 lineto -550 40 lineto
    -550 -40 lineto -40 -40 lineto -40 -550 lineto 40 -550 lineto 
    40 -40 lineto 550 -40 lineto 550 40 lineto 40 40 lineto closepath
  } def
  /BoldCrossPath {80 550 moveto -80 550 lineto -80 80 lineto -550 80 lineto
    -550 -80 lineto -80 -80 lineto -80 -550 lineto 80 -550 lineto 
    80 -80 lineto 550 -80 lineto 550 80 lineto 80 80 lineto closepath
  } def
  /Add {CrossPath fill} def
  /Mul {45 rotate CrossPath fill} def
  /BoldAdd {BoldCrossPath fill} def
  /BoldMul {45 rotate BoldCrossPath fill} def
  /Oplus {CirclePath .9 .9 scale CirclePath eofill .775 .775 scale CrossPath fill } def 
  /SolidOplus {CirclePath .775 .775 scale BoldCrossPath eofill} def 
  /BOplus {CirclePath .8 .8 scale CirclePath eofill .775 .775 scale BoldCrossPath fill} def 
  /Otimes {CirclePath .9 .9 scale CirclePath eofill 45 rotate .775 .775 scale CrossPath fill} def 
  /BOtimes {CirclePath .8 .8 scale CirclePath eofill 45 rotate .775 .775 scale BoldCrossPath fill } def 
  /SolidOtimes {CirclePath 45 rotate .775 .775 scale BoldCrossPath eofill} def 
  /BarPath {40 660 moveto -40 660 lineto -40 -660 lineto 40 -660 lineto closepath} def
  /Bar {BarPath fill} def
  /BoldBarPath {80 660 moveto -80 660 lineto -80 -660 lineto 80 -660 lineto closepath} def
  /BoldBar {BoldBarPath fill} def
  /DiamondPath {0 742.5 moveto -428.5 0 lineto 0 -742.5 lineto 428.5 0 lineto closepath} def
  /SolidDiamond {DiamondPath fill} def
  /Diamond {DiamondPath .865 .865 scale DiamondPath eofill} def
  /BoldDiamond {DiamondPath .73 .73 scale DiamondPath eofill} def
%%%
  /.notdef { } def
end
%
/BuildGlyph {
  exch
  begin 		
%  Metrics 1 index get exec 0
    0 0
%      BBoxes 3 index get exec
    -1000 -1000 1000 1000
%     -571.5 -742.5 571.5 742.5
    setcachedevice
    CharProcs begin load exec end
  end
} def
%
/BuildChar {
  1 index /Encoding get exch get
  1 index /BuildGlyph get exec
} bind def
%
end
/PSTricksDotFont exch definefont pop
%
%% end

%%EndProcSet
%%BeginProcSet: pst-node.pro 0 0
% $Id: pst-node.pro 645 2012-02-12 09:09:51Z herbert $
%%
%% PostScript prologue for pst-node.tex.
%% Version 1.13, 2011/11/21.
%%
%% This program can be redistributed and/or modified under the terms
%% of the LaTeX Project Public License Distributed from CTAN archives
%% in directory macros/latex/base/lppl.txt.
%
/tx@NodeDict 400 dict def tx@NodeDict begin
tx@Dict begin 			% from main pstricks dict
 /T /translate load def 
 /CP /currentpoint load def 
end
/NewNode { % on stack: { x y } boolean N@name type InitXnode 
  gsave 
  NodeScale                     % a bugfix for xelatex, it's empty for dvips
  /next exch def 		% { x y } boolean N@name type  
  dict dup 			% { x y } boolean N@name dict dict
  3 1 roll def 			% { x y } boolean dict N@name dict def
  exch { dup 3 1 roll def } if  % { x y } dict boolean
  begin 			% { x y } dict begin
  tx@Dict begin 
    STV CP T exec 		% set scaling
  end 
  /NodeMtrx CM def 		% save CM
  next 				% InitXNode
  end
  grestore 
} def
%
/InitPnode { 
  /Y ED /X ED 
  /NodePos { NodeSep Cos mul NodeSep Sin mul } def
} def
%
/InitCnode { 
  /r ED /Y ED /X ED 
  /NodePos { NodeSep r add dup Cos mul exch Sin mul } def 
} def
%
/GetRnodePos { 
  Cos 0 gt { /dx r NodeSep add def } { /dx l NodeSep sub def } ifelse 
  Sin 0 gt { /dy u NodeSep add def } { /dy d NodeSep sub def } ifelse 
  dx Sin mul abs dy 
  Cos mul abs gt { dy Cos mul Sin div dy } { dx dup Sin mul Cos Div } ifelse 
} def
%
/InitRnode { 
  /Y ED /X ED X sub /r ED /l X neg def Y add neg /d ED Y sub /u ED 
  /NodePos { GetRnodePos } def 
} def
%
/DiaNodePos { 
  w h mul w Sin mul abs h Cos mul abs add Div NodeSep add dup
  Cos mul exch Sin mul 
} def
%
/TriNodePos { 
  Sin s lt 
    { d NodeSep sub dup Cos mul Sin Div exch } 
    { w h mul w Sin mul h Cos abs mul add Div 
      NodeSep add dup Cos mul exch Sin mul 
    } ifelse 
} def
%
/InitTriNode { 
  sub 2 div exch 
  2 div exch 
  2 copy T 
  2 copy 4 index index /d ED 
  pop pop pop pop 
  -90 mul rotate 
  /NodeMtrx CM def 
  /X 0 def /Y 0 def 
  d sub abs neg /d ED 
  d add /h ED 
  2 div h mul h d sub Div /w ED 
  /s d w Atan sin def 
  /NodePos { TriNodePos } def 
} def
%
/OvalNodePos { 
  /ww w NodeSep add def 
  /hh h NodeSep add def 
  Sin ww mul Cos hh mul Atan dup cos ww mul exch sin hh mul 
} def
%
/GetCenter { begin X Y NodeMtrx transform CM itransform end } def
%
/XYPos { 
  dup sin exch cos Do 
  /Cos ED /Sin ED /Dist ED 
  Cos 0 gt 
    { Dist Dist Sin mul Cos div }
    { Cos 0 lt 
      { Dist neg Dist Sin mul Cos div neg }
      { 0 Dist Sin mul } ifelse 
    } ifelse 
  Do 
} def
%
/GetEdge {
  dup 0 eq 
    { pop begin 1 0 NodeMtrx dtransform 
      CM idtransform 
      exch atan sub 
      dup 
      sin /Sin ED 
      cos /Cos ED 
      /NodeSep ED 
      NodePos NodeMtrx dtransform CM idtransform end }
    { 1 eq {{exch}} {{}} ifelse /Do ED pop XYPos } ifelse 
} def
%
/AddOffset { 
  1 index 0 eq 
    { pop pop } 
    { 2 copy 5 2 roll cos mul add 4 1 roll sin mul sub exch } ifelse 
} def
%
/GetEdgeA { 
  NodeSepA AngleA NodeA NodeSepTypeA GetEdge 
  OffsetA AngleA AddOffset 
  yA add /yA1 ED 
  xA add /xA1 ED 
} def
%
/GetEdgeB { 
  NodeSepB AngleB NodeB NodeSepTypeB GetEdge 
  OffsetB AngleB AddOffset 
  yB add /yB1 ED 
  xB add /xB1 ED 
} def
%
/GetArmA { 
  ArmTypeA 0 eq 
    { /xA2 ArmA AngleA cos mul xA1 add def 
      /yA2 ArmA AngleA sin mul yA1 add def } 
    { ArmTypeA 1 eq {{exch}} {{}} ifelse 
      /Do ED 
      ArmA AngleA XYPos OffsetA AngleA AddOffset 
      yA add /yA2 ED 
      xA add /xA2 ED } ifelse 
} def
%
/GetArmB { 
  ArmTypeB 0 eq 
    { /xB2 ArmB AngleB cos mul xB1 add def 
      /yB2 ArmB AngleB sin mul yB1 add def } 
    { ArmTypeB 1 eq {{exch}} {{}} ifelse 
      /Do ED
      ArmB AngleB XYPos OffsetB AngleB AddOffset 
      yB add /yB2 ED 
      xB add /xB2 ED } ifelse 
} def
%
/InitNC { 
  /b ED /a ED % second and first node
  /NodeSepTypeB ED /NodeSepTypeA ED 
  /NodeSepB ED /NodeSepA ED 
  /OffsetB ED /OffsetA ED 
  tx@NodeDict a known tx@NodeDict b known and dup { 
    /NodeA a load def 
    /NodeB b load def 
    NodeA GetCenter /yA ED /xA ED 
    NodeB GetCenter /yB ED /xB ED } if 
} def
%
/LPutLine { 
  4 copy 
  3 -1 roll sub neg 3 1 roll sub Atan /NAngle ED 
  1 t sub mul 
  3 1 roll 1 t sub mul 
  4 1 roll t mul add /Y ED 
  t mul add /X ED 
} def
%
/LPutLines { 
  mark LPutVar counttomark 2 div 1 sub /n ED 
%  t floor dup n gt 
  t floor dup n ge 		% to allow npos<= hv 2008-08-14
  { pop n 1 sub /t 1 def } { dup t sub neg /t ED } ifelse 
  cvi 2 mul { pop } repeat 
  LPutLine 
  cleartomark 
} def
%
/BezierMidpoint { 
  /y3 ED /x3 ED /y2 ED /x2 ED /y1 ED /x1 ED /y0 ED /x0 ED /t ED 
  /cx x1 x0 sub 3 mul def 
  /cy y1 y0 sub 3 mul def 
  /bx x2 x1 sub 3 mul cx sub def 
  /by y2 y1 sub 3 mul cy sub def 
  /ax x3 x0 sub cx sub bx sub def 
  /ay y3 y0 sub cy sub by sub def 
  ax t 3 exp mul bx t t mul mul add 
  cx t mul add x0 add ay t 3 exp mul 
  by t t mul mul add cy t mul add
  y0 add 3 ay t t mul mul mul 2 
  by t mul mul add cy add 3 ax t t mul mul mul 
  2 bx t mul mul add cx add atan /NAngle ED 
  /Y ED /X ED 
} def
%
/HPosBegin { yB yA ge { /t 1 t sub def } if /Y yB yA sub t mul yA add def
} def
/HPosEnd { /X Y yyA sub yyB yyA sub Div xxB xxA sub mul xxA add def
/NAngle yyB yyA sub xxB xxA sub Atan def } def
/HPutLine { HPosBegin /yyA ED /xxA ED /yyB ED /xxB ED HPosEnd  } def
/HPutLines { HPosBegin yB yA ge { /check { le } def } { /check { ge } def
} ifelse /xxA xA def /yyA yA def mark xB yB LPutVar { dup Y check { exit
} { /yyA ED /xxA ED } ifelse } loop /yyB ED /xxB ED cleartomark HPosEnd 
} def
/VPosBegin { xB xA lt { /t 1 t sub def } if /X xB xA sub t mul xA add def
} def
/VPosEnd { /Y X xxA sub xxB xxA sub Div yyB yyA sub mul yyA add def
/NAngle yyB yyA sub xxB xxA sub Atan def } def
/VPutLine { VPosBegin /yyA ED /xxA ED /yyB ED /xxB ED VPosEnd  } def
/VPutLines { VPosBegin xB xA ge { /check { le } def } { /check { ge } def
} ifelse /xxA xA def /yyA yA def mark xB yB LPutVar { 1 index X check {
exit } { /yyA ED /xxA ED } ifelse } loop /yyB ED /xxB ED cleartomark
VPosEnd  } def
/HPutCurve { gsave newpath /SaveLPutVar /LPutVar load def LPutVar 8 -2
roll moveto curveto flattenpath /LPutVar [ {} {} {} {} pathforall ] cvx
def grestore exec /LPutVar /SaveLPutVar load def } def
/NCCoor { /AngleA yB yA sub xB xA sub Atan def /AngleB AngleA 180 add def
GetEdgeA GetEdgeB /LPutVar [ xB1 yB1 xA1 yA1 ] cvx def /LPutPos {
LPutVar LPutLine } def /HPutPos { LPutVar HPutLine } def /VPutPos {
LPutVar VPutLine } def LPutVar } def
%
/NCLine { 
  NCCoor 
  tx@Dict begin 
  ArrowA CP 4 2 roll 
  ArrowB 
  lineto pop pop
  end 
} def
%
/NCLines { 
  false NArray 
  n 0 eq 
    { NCLine } 
    { 2 copy yA sub exch xA sub Atan /AngleA ED 
      n 2 mul dup index exch index yB sub exch xB sub 
      Atan /AngleB ED 
      GetEdgeA GetEdgeB 
      /LPutVar [ xB1 yB1 n 2 mul 4 add 4 roll xA1 yA1 ] cvx def 
      mark LPutVar 
      tx@Dict begin false Line end 
      /LPutPos { LPutLines } def 
      /HPutPos { HPutLines } def 
      /VPutPos { VPutLines } def 
    } ifelse 
} def
%
/NCCurve { 
  GetEdgeA 
  GetEdgeB 
  xA1 xB1 sub yA1 yB1 sub Pyth 2 div dup 3 -1
roll mul /ArmA ED mul /ArmB ED /ArmTypeA 0 def /ArmTypeB 0 def GetArmA
GetArmB xA2 yA2 xA1 yA1 tx@Dict begin ArrowA end xB2 yB2 xB1 yB1 tx@Dict
begin ArrowB end curveto /LPutVar [ xA1 yA1 xA2 yA2 xB2 yB2 xB1 yB1 ]
cvx def /LPutPos { t LPutVar BezierMidpoint } def /HPutPos { { HPutLines
} HPutCurve } def /VPutPos { { VPutLines } HPutCurve } def } def
%
/NCAngles { 
  GetEdgeA GetEdgeB GetArmA GetArmB 
  /mtrx AngleA matrix rotate def 
  xA2 yA2 mtrx transform pop 
  xB2 yB2 mtrx transform exch pop 
  mtrx itransform 
  /y0 ED /x0 ED 
  mark ArmB 0 ne { xB1 yB1 } if 
  xB2 yB2 x0 y0 xA2 yA2 
  ArmA 0 ne { xA1 yA1 } if 
  tx@Dict begin false Line end 
  /LPutVar [ xB1 yB1 xB2 yB2 x0 y0 xA2 yA2 xA1 yA1 ] cvx def 
  /LPutPos { LPutLines } def
  /HPutPos { HPutLines } def 
  /VPutPos { VPutLines } def } def
%
/NCAngle { 
  GetEdgeA GetEdgeB GetArmB 
  /mtrx AngleA matrix rotate def 
  xB2 yB2 mtrx itransform pop xA1 yA1 mtrx itransform exch pop mtrx transform
  /y0 ED /x0 ED 
  mark 
  ArmB 0 ne { xB1 yB1 } if 
  xB2 yB2 x0 y0 xA1 yA1
  tx@Dict begin false Line end 
  /LPutVar [ xB1 yB1 xB2 yB2 x0 y0 xA1 yA1 ] cvx def 
  /LPutPos { LPutLines } def 
  /HPutPos { HPutLines } def 
  /VPutPos { VPutLines } def 
} def
%
/NCBar { 
  GetEdgeA GetEdgeB GetArmA GetArmB 
  /mtrx AngleA matrix rotate def
  xA2 yA2 mtrx itransform pop 
  xB2 yB2 mtrx itransform pop 
  sub dup 0 mtrx transform 
  3 -1 roll 0 gt 
    { /yB2 exch yB2 add def /xB2 exch xB2 add def }
    { /yA2 exch neg yA2 add def /xA2 exch neg xA2 add def } ifelse 
  mark 
  ArmB 0 ne { xB1 yB1 } if 
  xB2 yB2 xA2 yA2 ArmA 0 ne { xA1 yA1 } if 
  tx@Dict begin false Line end 
  /LPutVar [ xB1 yB1 xB2 yB2 xA2 yA2 xA1 yA1 ] cvx def 
  /LPutPos { LPutLines } def 
  /HPutPos { HPutLines } def 
  /VPutPos { VPutLines } def 
} def
%
/NCDiag { 
  /lineAngle ED
  GetEdgeA GetEdgeB GetArmA GetArmB mark
  lineAngle abs 0 gt {
    /xTemp xA2 10 add def
    /yTemp yA2 lineAngle dup sin exch cos div 10 mul add def
    /dY1 yTemp yA2 sub def
    /dX1 xTemp xA2 sub def
    /dY2 yB2 yB1 sub def
    /dX2 xB2 xB1 sub def
    dX1 abs 0.01 lt {
      /m2 dY2 dX2 div def
      /xB2 xA2 def
      /yB2 xA2 xB1 sub m2 mul yB1 add def
    }{
      dX2 abs 0.01 lt {
        /m1 dY1 dX1 div def
        /xB2 xB1 def
        /yB2 xB1 xA2 sub m1 mul yA2 add def
      }{%
        /m1 dY1 dX1 div def
        /m2 dY2 dX2 div def
        /xB2 m1 xA2 mul m2 xB1 mul sub yA2 sub yB1 add m1 m2 sub div def
        /yB2 xB2 xA2 sub m1 mul yA2 add def
      } ifelse
    } ifelse
  } if
  ArmB 0 ne { xB1 yB1 } if
  xB2 yB2 xA2 yA2 
  ArmA 0 ne { xA1 yA1 } if 
  tx@Dict begin false Line end
  /LPutVar [ xB1 yB1 xB2 yB2 xA2 yA2 xA1 yA1 ] cvx def 
  /LPutPos { LPutLines } def 
  /HPutPos { HPutLines } def 
  /VPutPos { VPutLines } def 
%
%  GetEdgeA GetEdgeB GetArmA GetArmB mark 
%  ArmB 0 ne { xB1 yB1 } if
%  xB2 yB2 xA2 yA2 
%  ArmA 0 ne { xA1 yA1 } if 
%  tx@Dict begin false Line end
%  /LPutVar [ xB1 yB1 xB2 yB2 xA2 yA2 xA1 yA1 ] cvx def 
%  /LPutPos { LPutLines } def 
%  /HPutPos { HPutLines } def 
%  /VPutPos { VPutLines } def 
} def
%
/NCDiagg { 
  /lineAngle ED
  GetEdgeA GetArmA 
  lineAngle abs 0 gt 
    { lineAngle }
    { yB yA2 sub xB xA2 sub Atan 180 add } ifelse 
  /AngleB ED
  GetEdgeB mark
  lineAngle abs 0 gt {
    /dY2 yA2 yA1 sub def
    /dX2 xA2 xA1 sub def
    lineAngle abs 90 eq {
      /m2 dY2 dX2 div def
      /yA2 xB xA2 sub m2 mul yA2 add def
      /xA2 xB def
    }{
      /m1 lineAngle dup sin exch cos div def % tan alpha
      dX2 abs 0.01 lt {
        /yA2 xA1 xB sub m1 mul yB add def
        /xA2 xA1 def
      }{%
        /m2 dY2 dX2 div def
        /xA2 m1 xB mul m2 xA2 mul sub yA2 add yB sub m1 m2 sub div def
        /yA2 xA2 xB sub m1 mul yB add def
      } ifelse
    } ifelse
  } if
  xB1 yB1 xA2 yA2
  ArmA 0 ne { xA1 yA1 } if
  tx@Dict begin false Line end
  /LPutVar [ xB1 yB1 xA2 yA2 xA1 yA1 ] cvx def
  /LPutPos { LPutLines } def
  /HPutPos { HPutLines } def
  /VPutPos { VPutLines } def
%
%  GetEdgeA GetArmA 
%  yB yA2 sub xB xA2 sub Atan 180 add /AngleB ED
%  GetEdgeB 
%  mark 
%  xB1 yB1 xA2 yA2 
%  ArmA 0 ne { xA1 yA1 } if 
%  tx@Dict begin false Line end 
%  /LPutVar [ xB1 yB1 xA2 yA2 xA1 yA1 ] cvx def 
%  /LPutPos { LPutLines } def 
%  /HPutPos { HPutLines } def 
%  /VPutPos { VPutLines } def 
} def
%
/NCLoop { 
  GetEdgeA GetEdgeB GetArmA GetArmB 
  /mtrx AngleA matrix rotate def 
  xA2 yA2 mtrx transform loopsize add /yA3 ED /xA3 ED 
  /xB3 xB2 yB2 mtrx transform pop def 
  xB3 yA3 mtrx itransform /yB3 ED /xB3 ED 
  xA3 yA3 mtrx itransform /yA3 ED /xA3 ED 
  mark ArmB 0 ne { xB1 yB1 } if 
  xB2 yB2 xB3 yB3 xA3 yA3 xA2 yA2 ArmA 0 ne { xA1 yA1 } if 
  tx@Dict begin false Line end 
  /LPutVar [ xB1 yB1 xB2 yB2 xB3 yB3 xA3 yA3 xA2 yA2 xA1 yA1 ] cvx def 
  /LPutPos { LPutLines } def 
  /HPutPos { HPutLines } def 
  /VPutPos { VPutLines } def 
} def
%
% DG/SR modification begin - May 9, 1997 - Patch 1
%/NCCircle { 0 0 NodesepA nodeA \tx@GetEdge pop xA sub 2 div dup 2 exp r
%r mul sub abs sqrt atan 2 mul /a ED r AngleA 90 add PtoC yA add exch xA add
%exch 2 copy /LPutVar [ 4 2 roll r AngleA ] cvx def /LPutPos { LPutVar t 360
%mul add dup 5 1 roll 90 sub \tx@PtoC 3 -1 roll add /Y ED add /X ED /NAngle ED
%
/NCCircle { 
  NodeSepA 0 NodeA 0 GetEdge pop 
  2 div dup 2 exp r r mul sub abs sqrt 
  atan 2 mul /a ED 
  r AngleA 90 add PtoC yA add exch xA add 
  exch 2 copy 
  /LPutVar [ 4 2 roll r AngleA ] cvx def 
  /LPutPos { 
    LPutVar t 360 mul add dup 5 1 roll 90 sub PtoC 
    3 -1 roll add 
    /Y ED add /X ED /NAngle ED
% DG/SR modification end
  } def 
  /HPutPos { LPutPos } def 
  /VPutPos { LPutPos } def 
  r AngleA 90 sub a add AngleA 270 add a sub 
  tx@Dict begin 
  /angleB ED /angleA ED /r ED 
  /c 57.2957 r Div def 
  /y ED /x ED 
} def
%
/NCBox { 
  /d ED /h ED 
  /AngleB yB yA sub xB xA sub Atan def 
  /AngleA AngleB 180 add def 
  GetEdgeA GetEdgeB 
  /dx d AngleB sin mul def 
  /dy d AngleB cos mul neg def 
  /hx h AngleB sin mul neg def 
  /hy h AngleB cos mul def 
  /LPutVar [ 
    xA1 hx add yA1 hy add xB1 hx add yB1 hy add 
    xB1 dx add yB1 dy add xA1 dx add yA1 dy add ] cvx def 
  /LPutPos { LPutLines } def 
  /HPutPos { xB yB xA yA LPutLine } def 
  /VPutPos { HPutPos } def 
  mark 
  LPutVar tx@Dict begin false Polygon end 
} def
%
/NCArcBox { 
  /l ED neg /d ED /h ED /a ED 
  /AngleA yB yA sub xB xA sub Atan def 
  /AngleB AngleA 180 add def 
  /tA AngleA a sub 90 add def 
  /tB tA a 2 mul add def 
  /r xB xA sub tA cos tB cos sub Div dup 0 eq { pop 1 } if def
  /x0 xA r tA cos mul add def 
  /y0 yA r tA sin mul add def 
  /c 57.2958 r div def 
  /AngleA AngleA a sub 180 add def 
  /AngleB AngleB a add 180 add def
  GetEdgeA GetEdgeB 
  /AngleA tA 180 add yA yA1 sub xA xA1 sub Pyth c mul sub def 
  /AngleB tB 180 add yB yB1 sub xB xB1 sub Pyth c mul add def 
  l 0 eq { 
    x0 y0 r h add AngleA AngleB arc x0 y0 r d add AngleB AngleA arcn 
  }{ 
    x0 y0 translate 
    /tA AngleA l c mul add def 
    /tB AngleB l c mul sub def
    0 0 r h add tA tB arc r h add 
    AngleB PtoC r d add 
    AngleB PtoC 2 copy 
    6 2 roll l arcto 4 { pop } repeat 
    r d add tB PtoC l arcto 4 { pop } repeat 
    0 0 r d add tB tA arcn r d add 
    AngleA PtoC r h add 
    AngleA PtoC 2 copy 6 2 roll 
    l arcto 4 { pop } repeat 
    r h add tA PtoC l arcto 4 { pop } repeat 
  } ifelse 
  closepath 
  /LPutVar [ x0 y0 r AngleA AngleB h d ] cvx def 
  /LPutPos { 
    LPutVar /d ED /h ED 
    /AngleB ED /AngleA ED 
    /r ED /y0 ED /x0 ED 
    t 1 le { 
      r h add AngleA 1 t sub mul AngleB t mul add dup 90 add /NAngle ED PtoC 
    }{t 2 lt { 
        /NAngle AngleB 180 add def r 2 t sub 
        h mul t 1 sub d mul add add AngleB PtoC 
      }{ 
        t 3 lt { 
          r d add AngleB 3 t sub mul AngleA 2 t sub
          mul add dup 90 sub /NAngle ED PtoC 
        }{ 
          /NAngle AngleA 180 add def 
          r 4 t sub d mul t 3 sub h mul add add AngleA PtoC 
        } ifelse 
      } ifelse 
    } ifelse
    y0 add /Y ED x0 add /X ED 
  } def 
  /HPutPos { LPutPos } def 
  /VPutPos { LPutPos } def 
} def
%
/Tfan { /AngleA yB yA sub xB xA sub Atan def GetEdgeA w xA1 xB sub yA1 yB
sub Pyth Pyth w Div CLW 2 div mul 2 div dup AngleA sin mul yA1 add /yA1
ED AngleA cos mul xA1 add /xA1 ED /LPutVar [ xA1 yA1 m { xB w add yB xB
w sub yB } { xB yB w sub xB yB w add } ifelse xA1 yA1 ] cvx def /LPutPos
{ LPutLines } def /VPutPos@ { LPutVar flag { 8 4 roll pop pop pop pop }
{ pop pop pop pop 4 2 roll } ifelse } def /VPutPos { VPutPos@ VPutLine }
def /HPutPos { VPutPos@ HPutLine } def mark LPutVar tx@Dict begin
/ArrowA { moveto } def /ArrowB { } def false Line closepath end } def
%
/LPutCoor { 
  NAngle 
  tx@Dict begin /NAngle ED end 
  gsave 
  CM STV 
  CP Y sub neg exch X sub neg exch moveto 
  setmatrix CP 
  grestore 
} def
%
/LPut { 
  tx@NodeDict /LPutPos known 
    { LPutPos } { CP /Y ED /X ED /NAngle 0 def } ifelse 
  LPutCoor  
} def
%
/HPutAdjust { 
  Sin Cos mul 0 eq 
    { 0 } 
    { d Cos mul Sin div flag not { neg } if 
      h Cos mul Sin div flag { neg } if 
      2 copy gt { pop } { exch pop } ifelse 
    } ifelse 
  s add flag { r add neg }{ l add } ifelse 
  X add /X ED 
} def
%
/VPutAdjust { 
  Sin Cos mul 
  0 eq 
    { 0 }
    { l Sin mul Cos div flag { neg } if
      r Sin mul Cos div flag not { neg } if 
      2 copy gt { pop } { exch pop } ifelse 
    } ifelse 
  s add flag { d add } { h add neg } ifelse 
  Y add /Y ED 
} def
%
%
end
%
% END pst-node.pro

%%EndProcSet
%%BeginProcSet: pst-3d.pro 0 0
%% $Id: pst-3d.pro 247 2010-01-04 22:45:42Z herbert $
% PostScript prologue for pst-3d.tex.
% Version 0.01, 2010/01/01 
%
/tx@3Ddict 300 dict def 
tx@3Ddict begin
%
/SetMatrixThreeD {
  dup sin /e ED cos /f ED
  /p3 ED /p2 ED /p1 ED
  p1 0 eq
  { /a 0 def /b p2 0 le { 1 } { -1 } ifelse def
    p3 p2 abs
  }
  { p2 0 eq
    { /a p1 0 lt { -1 } { 1 } ifelse def /b 0 def
      p3 p1 abs
    }
    { p1 dup mul p2 dup mul add sqrt dup
      p1 exch div /a ED
      p2 exch div neg /b ED
      p3 p1 a div
    }
    ifelse
  }
  ifelse
  atan dup sin /c ED cos /d ED
  /Matrix3D
  [
    b f mul c a mul e mul sub
    a f mul c b mul e mul add
    d e mul
    b e mul neg c a mul f mul sub
    a e mul neg c b mul f mul add
    d f mul
  ] def
} def
%
/ProjThreeD {
  /z ED /y ED /x ED
  Matrix3D aload pop
  z mul exch y mul add exch x mul add
  4 1 roll
  z mul exch y mul add exch x mul add
  exch
} def
%
/SetMatrixEmbed {
  SetMatrixThreeD
  Matrix3D aload pop
  /z3 ED /z2 ED /z1 ED /x3 ED /x2 ED /x1 ED
  SetMatrixThreeD
  [
  Matrix3D aload pop
  z3 mul exch z2 mul add exch z1 mul add 4 1 roll
  z3 mul exch z2 mul add exch z1 mul add
  Matrix3D aload pop
  x3 mul exch x2 mul add exch x1 mul add 4 1 roll
  x3 mul exch x2 mul add exch x1 mul add
  3 -1 roll 3 -1 roll 4 -1 roll 8 -3 roll 3 copy
  x3 mul exch x2 mul add exch x1 mul add 4 1 roll
  z3 mul exch z2 mul add exch z1 mul add
  ]
  concat
} def
%
/TMSave {
  tx@Dict /TMatrix known not { /TMatrix { } def /RAngle { 0 } def } if 
  /TMatrix [ TMatrix CM ] cvx def 
} def
%
/TMRestore { CP /TMatrix [ TMatrix setmatrix ] cvx def moveto } def
%
/TMChange {
  TMSave
  /cp [ currentpoint ] cvx def % ??? Check this later.
  CM
  CP T STV
  CM matrix invertmatrix    % Inv(M')
  matrix concatmatrix       % M Inv(M')
  exch exec
  concat cp moveto
} def
%
end % of tx@3Ddict
%%
%% End of file `pst-3d.pro'.

%%EndProcSet
%%BeginProcSet: pst-3dplot.pro 0 0
%% $Id: pst-3dplot.pro 298 2010-03-13 08:46:53Z herbert $
%%
%% This is file `pst-3dplot.pro',
%%
%% IMPORTANT NOTICE:
%%
%% Package `pst-3dplot.tex'
%%
%% Herbert Voss <voss _at_ PSTricks.de>
%%
%% This program can be redistributed and/or modified under the terms
%% of the LaTeX Project Public License Distributed from CTAN archives
%% in directory macros/latex/base/lppl.txt.
%%
%% DESCRIPTION:
%%   `pst-3dplot' is a PSTricks package to draw 3d curves and graphical objects
%%
%%
%% version 0.31 / 2010-02-20  Herbert Voss <hvoss _at_ tug.org>
%% with contributions of Darrell Lamm <darrell.lamm _at_ gtri.gatech.edu<
%%            
%
/tx@3DPlotDict 200 dict def
tx@3DPlotDict begin
%
/printDot { gsave 2 copy 2 0 360 arc fill stroke grestore } def
%
/saveCoor { 
  dzUnit mul /z ED
  dyUnit mul /y ED
  dxUnit mul /x ED
} def
%
/3Dto2D { % true or false on stack
  { RotatePoint } if
  1 { %  dummy loop, will run only 1 time, allows exit 
    coorType 0 le {                                               % the default |
      /x2D x leftHanded not { neg } if Alpha cos mul y Alpha sin mul add def %  /\  co system
      /y2D x leftHanded { neg } if Alpha sin mul y Alpha cos mul add neg Beta sin mul z Beta cos mul add def
      exit } if
    coorType 1 le { 
      /x2D y x Alpha 90 sub sin mul sub def  %  |/_  co system, no shortened x axis
      /y2D z x Alpha 90 sub cos mul sub def 
      exit } if
    coorType 2 le { % coorType |/_ with a 1/sqrt(2) shortend x-axis and 135 degrees 
      /x2D y x 0.5 mul sub def
      /y2D z x 0.5 mul sub def 
      exit } if
    coorType 3 le { % coorType |/_ with a 1/sqrt(2) shortend x-axis and 135 degrees 
      /x2D y x -0.5 mul sub def
      /y2D z x -0.5 mul sub def 
      exit } if
    coorType 4 le { % Normalbild in Trimetrie Skalierung so, dass coorType2
       /x2D x -0.5 mul y 1 mul add def
       /y2D x -0.5 mul y -0.25 mul add z 1 mul add def
       exit } if
  } repeat
} def
/ConvertTo2D { true 3Dto2D } def
/ConvertTo2DWithoutRotating { false 3Dto2D } def
%
/Conv3D2D { /z ED /y ED /x ED ConvertTo2D x2D y2D } def
%
/ConvertToCartesian {
  /latitude exch def
  /longitude exch def
  /Radius exch def
  1 { %  dummy loop, will run only 1 time, allows exit
    SphericalCoorType 0 le {                                               % the default |
     /z { Radius latitude sin mul } def
     /x { Radius longitude cos mul latitude cos mul } def
     /y { Radius longitude sin mul latitude cos mul } def
      exit } if
    SphericalCoorType 2 le {
     /z { Radius longitude cos mul } def
     /x { Radius longitude sin mul latitude cos mul} def
     /y { Radius longitude sin mul latitude sin mul } def
      exit } if
  } repeat
} def
%
/ConvCylToCartesian { % r phi h -> x y z
  3 1 roll			% h r phi
  /Phi ED
  /Radius ED			% h->z on stack
  Radius Phi cos mul exch 	% x z
  Radius Phi sin mul exch	% x y z
} def
%
/SphericalTo2D {
  x y z ConvertToCartesian ConvertTo2D
} def
%
/CylinderTo2D { %  r phi h
  x y z ConvCylToCartesian ConvertTo2D
} def
%
/convertStackTo2D {
  counttomark
  /n ED /n3 n 3 div cvi def
  n3 {
    n -3 roll
    SphericalCoor { ConvertToCartesian } { saveCoor } ifelse
    ConvertTo2D
    x2D xUnit y2D yUnit
    /n n 1 sub def
  } repeat
} def
%
% the angle in the parameter equation for an ellipse is not proportional to the real angle!
% phi=atan(b*tan(angle)/a)+floor(angle/180+0.5)*180
%
/getPhi { % on stack: vecA vecB angle 
  3 dict begin
  /angle exch def /vecB exch def /vecA exch def
  angle cvi 90 mod 0 eq { angle } { vecA angle tan mul vecB atan 
  angle 180 div .5 add floor 180 mul add } ifelse 
  end
} def
%
/RotSet (set ) def
%
/eulerRotation false def
% Matrix multiplication procedure
/matmul {

  /M@tMulDict 20 dict def
  M@tMulDict begin
  /m2 ED
  /m1 ED
  m1 dup length 2 sub 2 getinterval aload pop
  /col1max ED
  /row1max ED
  m2 dup length 2 sub 2 getinterval aload pop
  /col2max ED
  /row2max ED
  /m3 row1max col2max mul 2 add array def
  m3 dup length 2 sub row1max col2max 2 array astore putinterval
  0 1 row1max 1 sub {
   /row ED
   0 1 col2max 1 sub {
    /col ED
    /sum 0 def
    0 1 col1max 1 sub{
    /rowcol ED
    sum
    m1 row col1max mul rowcol add get
    m2 rowcol col2max mul col add get
    mul add 
    /sum ED
    } for
    m3 row col2max mul col add sum put
   } for
  } for
  m3
  end % end of M@tMulDict

} def
%
/SetMQuaternion {

  /MnewTOold 11 array def

  /Qu@ternionDict 30 dict def
  Qu@ternionDict begin

  /normRotVec  xRotVec yRotVec zRotVec 3 array astore VecNorm  def
  normRotVec 0 gt
  {/xRotVecNorm xRotVec normRotVec div def
   /yRotVecNorm yRotVec normRotVec div def
   /zRotVecNorm zRotVec normRotVec div def
   RotAngle}
  {/xRotVecNorm 1 def
   /yRotVecNorm 0 def
   /zRotVecNorm 0 def 
   0} ifelse

  2 div dup
  /q0 exch cos def
      sin dup dup
  /q1 exch xRotVecNorm mul def
  /q2 exch yRotVecNorm mul def
  /q3 exch zRotVecNorm mul def

  /q0q0 q0 q0 mul def
  /q0q1 q0 q1 mul def
  /q0q2 q0 q2 mul def
  /q0q3 q0 q3 mul def

  /q1q1 q1 q1 mul def
  /q1q2 q1 q2 mul def
  /q1q3 q1 q3 mul def

  /q2q2 q2 q2 mul def
  /q2q3 q2 q3 mul def

  /q3q3 q3 q3 mul def

  MnewTOold 0 q0q0 q1q1 add q2q2 sub q3q3 sub put
  MnewTOold 1 q1q2 q0q3 sub 2 mul put
  MnewTOold 2 q1q3 q0q2 add 2 mul put

  MnewTOold 3 q1q2 q0q3 add 2 mul put
  MnewTOold 4 q0q0 q1q1 sub q2q2 add q3q3 sub put
  MnewTOold 5 q2q3 q0q1 sub 2 mul put

  MnewTOold 6 q1q3 q0q2 sub 2 mul put
  MnewTOold 7 q2q3 q0q1 add 2 mul put
  MnewTOold 8 q0q0 q1q1 sub q2q2 sub q3q3 add put

  MnewTOold 9 3 put
  MnewTOold 10 3 put

  end % end of Qu@ternionDict

} def
%
/SetMxyz {
  1.0 0.0 0.0  0.0 1.0 0.0  0.0 0.0 1.0  3 3  11 array astore /MnewTOold ED
  RotSequence cvx exec % Now create a new MnewTOold using xyz, etc.
} def
%
/ConcatMQuaternion {
  MnewTOold % Push onto stack
  SetMQuaternion % Uses [xyz]RotVec and RotAngle to make MnewToOld 
  MnewTOold matmul /MnewTOold ED
} def
%
/ConcatMxyz {
  MnewTOold % Push onto stack
  SetMxyz % Uses RotX, etc. to set MnewTOold 
  MnewTOold matmul /MnewTOold ED
} def
%
/RotatePoint{
  MnewTOold x y z  3 1  5 array astore matmul
  0 3 getinterval aload pop 
  /z ED 
  /y ED 
  /x ED 
} def
%
/makeMoldTOnew {
  /MoldTOnew 11 array def
  MoldTOnew 0 MnewTOold 0 get put
  MoldTOnew 1 MnewTOold 3 get put
  MoldTOnew 2 MnewTOold 6 get put
  MoldTOnew 3 MnewTOold 1 get put
  MoldTOnew 4 MnewTOold 4 get put
  MoldTOnew 5 MnewTOold 7 get put
  MoldTOnew 6 MnewTOold 2 get put
  MoldTOnew 7 MnewTOold 5 get put
  MoldTOnew 8 MnewTOold 8 get put
  MoldTOnew 9               3 put
  MoldTOnew 10              3 put
} def
%
/RotXaxis { 
  eulerRotation 
  {1 0 0}
  {makeMoldTOnew MoldTOnew  1 0 0  3 1  5 array astore matmul
   0 3 getinterval aload pop} ifelse
  /zRotVec ED
  /yRotVec ED
  /xRotVec ED
  /RotAngle RotX def
  ConcatMQuaternion
} def
/RotYaxis { 
  eulerRotation 
  {0 1 0}
  {makeMoldTOnew MoldTOnew  0 1 0  3 1  5 array astore matmul
   0 3 getinterval aload pop} ifelse
  /zRotVec ED
  /yRotVec ED
  /xRotVec ED
  /RotAngle RotY def
  ConcatMQuaternion
} def
/RotZaxis { 
  eulerRotation 
  {0 0 1}
  {makeMoldTOnew MoldTOnew  0 0 1  3 1  5 array astore matmul
   0 3 getinterval aload pop} ifelse
  /zRotVec ED
  /yRotVec ED
  /xRotVec ED
  /RotAngle RotZ def
  ConcatMQuaternion
} def
/xyz { RotXaxis RotYaxis RotZaxis } def
/yxz { RotYaxis RotXaxis RotZaxis } def
/yzx { RotYaxis RotZaxis RotXaxis } def
/xzy { RotXaxis RotZaxis RotYaxis } def
/zxy { RotZaxis RotXaxis RotYaxis } def
/zyx { RotZaxis RotYaxis RotXaxis } def
/quaternion { } def % Null
%
/VecNorm { 0 exch { dup mul add } forall sqrt } def
%
/UnitVec {			% on stack is [a]; returns a vector with [a][a]/|a|=1 
  dup VecNorm /norm ED
  norm 0 lt {/norm 0 def} if
  { norm div } forall 3 array astore } def
%
/AxB {				% on the stack are the two vectors [a][b]
    aload pop /b3 ED /b2 ED /b1 ED
    aload pop /a3 ED /a2 ED /a1 ED
    a2 b3 mul a3 b2 mul sub
    a3 b1 mul a1 b3 mul sub
    a1 b2 mul a2 b1 mul sub
    3 array astore } def
%
/AaddB {			% on the stack are the two vectors [a][b]
    aload pop /b3 ED /b2 ED /b1 ED
    aload pop /a3 ED /a2 ED /a1 ED
    a1 b1 add a2 b2 add a3 b3 add
    3 array astore } def
%
/AmulC {			% on stack is [a] and c; returns [a] mul c
    /factor ED { factor mul } forall 3 array astore } def
%
%
/setColorLight { % expects 7 values on stack C M Y K xL yL zL
% les rayons de lumi�re
  xLight dup mul yLight dup mul zLight dup mul add add sqrt /NormeLight ED
% the color values
  /K ED
  /Yellow ED
  /Magenta ED
  /Cyan ED
} def
%
/facetteSphere {
  newpath
  /Xpoint Rsphere theta cos mul phi cos mul CX add def
  /Ypoint Rsphere theta sin mul phi cos mul CY add def
  /Zpoint Rsphere phi sin mul CZ add def
  Xpoint Ypoint Zpoint tx@3Ddict begin ProjThreeD end moveto
  theta 1 theta increment add {%
    /theta1 ED
    /Xpoint Rsphere theta1 cos mul phi cos mul CX add def
    /Ypoint Rsphere theta1 sin mul phi cos mul CY add def
    /Zpoint Rsphere phi sin mul CZ add def
    Xpoint Ypoint Zpoint tx@3Ddict begin ProjThreeD end  lineto
  } for
  phi 1 phi increment add {
    /phi1 ED
    /Xpoint Rsphere theta increment add cos mul phi1 cos mul CX add def
    /Ypoint Rsphere theta increment add sin mul phi1 cos mul CY add def
    /Zpoint Rsphere phi1 sin mul CZ add def
    Xpoint Ypoint Zpoint tx@3Ddict begin ProjThreeD end lineto
  } for
  theta increment add -1 theta {%
    /theta1 ED
    /Xpoint Rsphere theta1 cos mul phi increment add cos mul CX add def
    /Ypoint Rsphere theta1 sin mul phi increment add cos mul CY add def
    /Zpoint Rsphere phi increment add sin mul CZ add def
    Xpoint Ypoint Zpoint tx@3Ddict begin ProjThreeD end lineto
  } for
  phi increment add -1 phi {
    /phi1 ED
    /Xpoint Rsphere theta cos mul phi1 cos mul CX add def
    /Ypoint Rsphere theta sin mul phi1 cos mul CY add def
    /Zpoint Rsphere phi1 sin mul CZ add def
    Xpoint Ypoint Zpoint tx@3Ddict begin ProjThreeD end lineto
  } for
  closepath 
} def
%
/MaillageSphere { 
% on stack must be x y z Radius increment C M Y K 
  setColorLight
  /increment ED
  /Rsphere ED
  /CZ ED
  /CY ED
  /CX ED
  /StartTheta 0 def
  /condition { PSfacetteSphere 0 ge } def
  -90 increment 90 increment sub {%
    /phi ED
    StartTheta increment 360 StartTheta add increment sub {%
      /theta ED
      % Centre de la facette
      /Xpoint Rsphere theta increment 2 div add cos mul phi increment 2 div add cos mul CX add def
      /Ypoint Rsphere theta increment 2 div add sin mul phi increment 2 div add cos mul CY add def
      /Zpoint Rsphere phi increment 2 div add sin mul CZ add def
      % normale a la facette
      /nXfacette Xpoint CX sub def
      /nYfacette Ypoint CY sub def
      /nZfacette Zpoint CZ sub def
      % test de visibilite
      /PSfacetteSphere 
        vX nXfacette mul
        vY nYfacette mul add
        vZ nZfacette mul add
      def
      condition {
        gsave
        facetteSphere
        /cosV { 1 xLight nXfacette mul
          yLight nYfacette mul
          zLight nZfacette mul
          add add
          NormeLight
          nXfacette dup mul
          nYfacette dup mul
          nZfacette dup mul
          add add sqrt mul div sub } bind def
        Cyan cosV mul Magenta cosV mul Yellow cosV mul K cosV mul setcmykcolor fill 
	grestore
%	0 setgray
        showgrid { facetteSphere stroke } if
      } if 
    } for
    % /StartTheta StartTheta increment 2 div add def
  } for
} def
%
%---------------------- Cylinder ---------------------------
%
/PlanCoupeCylinder { %
  /TableauxPoints [
    0 1 359 { 
      /phi ED 
      [ Radius phi Height ConvCyl2d ] % on décrit le cercle
    } for
  ] def
  newpath
  TableauxPoints 0 get aload pop moveto
  1 1 359 { TableauxPoints exch get aload pop lineto } for
  closepath
} def
%
/facetteCylinder { % 
    newpath
    Radius phi currentHeight ConvCyl2d moveto
    phi 1 phi dAngle add  { % loop variable on stack
      Radius exch currentHeight ConvCyl2d lineto        
    } for
    phi dAngle add -1 phi { %	fill dHeight
      Radius exch currentHeight dHeight add ConvCyl2d lineto 
    } for
    closepath
  } def % facette
%
/MaillageCylinder { % on stack true or false for saving values
    { setColorLight  % expects 4 values on stack C M Y K
      /dHeight ED /dAngle ED /Height ED /Radius ED
      /CZ ED /CY ED /CX ED } if
%     
    0 dHeight Height dHeight sub {
      /currentHeight ED
      0 dAngle 360 dAngle sub {
        /phi ED
% Normal vector of the center
        /nXfacetteCylinder Radius phi dAngle 2 div add cos mul CX add def 
        /nYfacetteCylinder Radius phi dAngle 2 div add sin mul CY add def 
        /nZfacetteCylinder currentHeight dHeight 2 div add CZ add def 
        /NormeN 
          nXfacetteCylinder dup mul
          nYfacetteCylinder dup mul
          nZfacetteCylinder dup mul
          add add sqrt def
        NormeN 0 eq { /NormeN 1e-10 def } if
% test de visibilité
       /PSfacetteCylinder 
    	    vX nXfacetteCylinder mul
            vY nYfacetteCylinder mul add
            vZ nZfacetteCylinder mul add def
       condition {
         facetteCylinder
         /cosV 
	   1 xLight nXfacetteCylinder mul
           yLight nYfacetteCylinder mul
           zLight nZfacetteCylinder mul
           add add
	   NormeLight NormeN mul div sub def
         Cyan Magenta Yellow K
         cosV mul 4 1 roll cosV mul 4 1 roll 
	 cosV dup mul mul 4 1 roll cosV dup mul mul 4 1 roll
         setcmykcolor fill
          showgrid { 
            0 setgray
            facetteCylinder % drawing the segments
            stroke } if
       } if
     } for
    } for
} def
%
%------------------------ Cylinder type II -----------------------
%
/MoveTo { Conv3D2D moveto } def
/LineTo { Conv3D2D lineto } def

/IIIDEllipse { % x y z rA rB startAngle endAngle Wedge
  /dAngle 1 def
  /isWedge ED
  /endAngle ED
  /startAngle ED
  /radiusB ED
  /radiusA ED
  startAngle cos radiusA mul startAngle sin radiusB mul 0 
  isWedge { 0 0 moveto LineTo }{ MoveTo } ifelse
  /Angle startAngle def
  startAngle dAngle endAngle {
    /Angle ED
    Angle cos radiusA mul Angle sin radiusB mul 0 LineTo  
  } for
  isWedge { 0 0 lineto } if
} def

/IIIDCircle { % x y z r startAngle endAngle Wedge
  7 3 roll % startAngle endAngle Wedge x y z r
  dup      % startAngle endAngle Wedge x y z r r
  8 -3 roll
  IIIDEllipse 
} def

/IIIDWedge { % x y z r startAngle endAngle
  true IIIDCircle
} def

/IIIDCylinder {% x y z r h start end wedge
  /isWedge ED
  /increment ED
  /endAngle ED
  /startAngle ED
  /height ED
  /radius ED
  startAngle increment endAngle {
    /Angle ED
    radius Angle 0 ConvCylToCartesian MoveTo  
    radius Angle height ConvCylToCartesian LineTo  
  } for
  stroke
} def
%
%---------------------- Box ---------------------------
%
/PlanCoupeBox { % x y z
  /TableauxPoints [
      [ CX CY CZ Height add ConvBox2d ] % top or bottom
      [ CX CY Depth add CZ Height add ConvBox2d ]
      [ CX Width add CY Depth add CZ Height add ConvBox2d ] 
      [ CX Width add CY CZ Height add ConvBox2d ] 
      [ CX CY CZ Height add ConvBox2d ] % bottom
    ] def
    newpath
    TableauxPoints 0 get aload pop moveto
    0 1 3 {
      TableauxPoints exch get aload pop
      lineto } for
    closepath
} def
%
/facetteBox { % 
    newpath
    dup
    1 eq { % back
      CX CY CZ ConvBox2d moveto
      CX CY CZ Height add ConvBox2d lineto
      CX Width add CY CZ Height add ConvBox2d lineto
      CX Width add CY CZ ConvBox2d lineto
      CX CY CZ ConvBox2d lineto
    } if
    dup
    2 eq { % right
      CX CY CZ ConvBox2d moveto
      CX CY CZ Height add ConvBox2d lineto
      CX CY Depth add CZ Height add ConvBox2d lineto
      CX CY Depth add CZ ConvBox2d lineto
      CX CY CZ ConvBox2d lineto
    } if
    dup
    3 eq { % left
      CX Width add CY CZ ConvBox2d moveto
      CX Width add CY Depth add CZ ConvBox2d lineto
      CX Width add CY Depth add CZ Height add ConvBox2d lineto
      CX Width add CY CZ Height add ConvBox2d lineto
      CX Width add CY CZ ConvBox2d lineto
    } if
    4 eq { % front
      CX CY Depth add CZ ConvBox2d moveto
      CX CY Depth add CZ Height add ConvBox2d lineto
      CX Width add CY Depth add CZ Height add ConvBox2d lineto
      CX Width add CY Depth add CZ ConvBox2d lineto
      CX CY Depth add CZ ConvBox2d lineto
    } if
    closepath
  } def % facette
%
/TestPlane { % on stack x y z of the plane center and # of plane
  /nZfacetteBox ED /nYfacetteBox ED /nXfacetteBox ED
  /Plane ED
  /NormeN 
    nXfacetteBox dup mul
    nYfacetteBox dup mul
    nZfacetteBox dup mul
    add add sqrt def
  NormeN 0 eq { /NormeN 1e-10 def } if
% test de visibilite
  /PSfacetteBox 
    vX nXfacetteBox mul
    vY nYfacetteBox mul add
    vZ nZfacetteBox mul add def
  condition {
    Plane facetteBox
         /cosV 
	   1 xLight nXfacetteBox mul
           yLight nYfacetteBox mul
           zLight nZfacetteBox mul
           add add
	   NormeLight NormeN mul div sub def
         Cyan Magenta Yellow K
         cosV mul 4 1 roll cosV mul 4 1 roll 
	 cosV dup mul mul 4 1 roll cosV dup mul mul 4 1 roll
         setcmykcolor fill
         0 setgray
         Plane facetteBox % drawing the segments
         stroke
       } if
} def
%
/MaillageBox { % on stack true or false for saving values
    { setColorLight  % expects 4 values on stack C M Y K 
      /Depth ED /Height ED /Width ED
      /CZ ED /CY ED /CX ED } if
%
% Normal vector of the box center
  /PlaneSet [
    [ Width 2 div CX add 
      CY 
      Height 2 div CZ add ] % normal back
    [ CX 
      Depth 2 div CY add 
      Height 2 div CZ add ] % normal right
    [ Width CX add 
      Depth 2 div CY add 
      Height 2 div CZ add ] % normal left
    [ Width 2 div CX add 
      Depth CY add 
      Height 2 div CZ add ] % normal front
  ] def
  PlaneSequence length 0 eq { % user defined?
    Alpha abs cvi 360 mod /iAlpha ED
    iAlpha 90 lt { [ 1 2 3 4 ]  
      }{ iAlpha 180 lt { [ 2 4 1 3 ]  
        }{ iAlpha 270 lt { [ 3 4 1 2 ] }{ [ 3 1 4 2] } ifelse } ifelse } ifelse 
  }{ PlaneSequence } ifelse 
  { dup 1 sub PlaneSet exch get aload pop TestPlane } forall
} def
%
%--------------------------- Paraboloid -----------------------------
/PlanCoupeParaboloid {
    /Z height store
    /V {Z sqrt} bind def
    /TableauxPoints [
      0 1 359 { 
        /U ED [ U U Z V calculate2DPoint ] % on decrit le cercle
      } for
    ] def
    newpath
    TableauxPoints 0 get aload pop moveto
    0 1 359 {
      /compteur ED
      TableauxPoints compteur get aload pop
      lineto } for
    closepath
} def
%
/facetteParaboloid{
    newpath
    U U Z V calculate2DPoint moveto
    U 1 U increment add  {%
      /U1 ED
      U1 U1 Z V calculate2DPoint lineto
    } for
    Z pas10 Z pas add pas10 add{
      /Z1 ED
      /V {Z1 sqrt} bind def
      U1 U1 Z1 V calculate2DPoint lineto
    } for
    U increment add -1 U {%
      /U2 ED
      U2 U2 Z pas add V calculate2DPoint lineto
    } for
    Z pas add pas10 sub pas10 neg Z pas10 sub {
      /Z2 ED
      /V Z2 abs sqrt def
      U U Z2 V calculate2DPoint lineto
    } for
    closepath
} def % facette
%
/MaillageParaboloid {
  % on stack true or false for saving values
    { setColorLight  % expects 7 values on stack C M Y K xL yL zL 
%      /CZ ED /CY ED /CX ED 
    } if    
    0 pas height pas sub {%
      /Z ED
      /V Z sqrt def
      0 increment 360 increment sub {%
        /U ED
% Centre de la facette
        /Ucentre U increment 2 div add def
        /Vcentre Z pas 2 div add sqrt def
% normale à la facette
        /nXfacetteParaboloid 2 Vcentre dup mul mul Ucentre cos mul radius mul def
        /nYfacetteParaboloid 2 Vcentre dup mul mul Ucentre sin mul radius mul def
        /nZfacetteParaboloid Vcentre neg radius dup mul mul def
        /NormeN {
          nXfacetteParaboloid dup mul
          nYfacetteParaboloid dup mul
          nZfacetteParaboloid dup mul
          add add sqrt} bind def
        NormeN 0 eq {/NormeN 1e-10 def} if
% test de visibilit�
       /PSfacetteParaboloid vX nXfacetteParaboloid mul
                  vY nYfacetteParaboloid mul add
                  vZ nZfacetteParaboloid mul add def
       condition {
         facetteParaboloid
         /cosV 1 xLight nXfacetteParaboloid mul
           yLight nYfacetteParaboloid mul
           zLight nZfacetteParaboloid mul
           add add
           NormeLight
           NormeN mul div sub def
         Cyan Magenta Yellow K  
         cosV mul 4 1 roll cosV mul 4 1 roll cosV dup mul mul 4 1 roll cosV dup mul mul 4 1 roll
         setcmykcolor fill
         showgrid {
           0 setgray
           facetteParaboloid
           stroke } if
       } if
     } for
    } for
} def
%
% ------------------------------------ math stuff ----------------------------------
%
% Matrix A in arrays of rows A[[row1][row2]...]
% with [row1]=[a11 a12 ... b1]
% returns on stack solution vector X=[x1 x2 ... xn]
/SolveLinEqSystem { 				% on stack matrix M=[A,b] (A*x=b)
  10 dict begin					% hold all ocal
    /A exch def
    /Rows A length def         			% Rows = number of rows
    /Cols A 0 get length def   			% Cols = number of columns
    /Index [ 0 1 Rows 1 sub { } for ] def	% Index = [0 1 2 ... Rows-1]
    /col 0 def
    /row  0 def
    /PR Rows array def 				% PR[c] = pivot row for row row
  { 						% starts the loop, find pivot entry in row r
    col Cols ge row  Rows ge or { exit } if	% col < Cols and row < Rows else exit
    /pRow row def  				% pRow = pivot row		
    /max A row  get col get abs def		% get A[row[col]], first A[0,0] 
    row 1 add 1 Rows 1 sub { 			% starts for loop 1 1 Rows-1
      /j exch def				% index counter
      /x A j get col get abs def		% get A[j[r]]
      x max gt {				% x>max, then save position
        /pRow j def
        /max x def
      } if
    } for					% now we have the row with biggest A[0,1]
						% with pRow = the pivot row
    max 0 gt {					% swap entries pRow and row  in i 
      /tmp Index row  get def
      Index row  Index pRow get put
      Index pRow tmp put			% and columns pRow and row  in A
      /tmp A row get def
      A row  A pRow get put
      A pRow tmp put   				% pivot
      /row0  A row  get def 			% the pivoting row
      /p0 row0  col get def 			% the pivot value
      row 1 add 1 Rows 1 sub { 			% start for loop
        /j exch def
        /c1 A j get def
        /p c1 col get p0 div def
        c1 col p put				% subtract (p1/p0)*row[i] from row[j]
        col 1 add 1 Cols 1 sub {		% start for loop
          /i exch def
          c1 dup i exch 			% c1 i c1
          i get row0 i get p mul sub put
        } for
      } for
      PR row col put
      /col col 1 add def
      /row row 1 add def
    }{						% all zero entries
      /row row 1 add def			% continue loop with same row
    } ifelse
  } loop
  /X A def					% solution vector
  A Rows 1 sub get dup
  Cols 1 sub get exch
  Cols 2 sub get div
  X Rows 1 sub 3 -1 roll put  			% X[n]
  Rows 2 sub -1 0 {				% for loop to calculate X[i]
    /xi exch def				% current index
    A xi get 					% i-th row
    /Axi exch def
    /sum 0 def
    Cols 2 sub -1 xi 1 add { 
      /n exch def
      /sum sum Axi n get X n get mul add def 
    } for
    Axi Cols 1 sub get 				% b=Axi[Cols-1]
    sum sub 					% b-sum
    Axi xi get div				% b-sum / Axi[xi]
    X xi 3 -1 roll put  			% X[xi]
  } for
  X
  end 
} def
%
% u -> e_u with |e_u|=1 
/vector-unit { 1 dict begin
  dup vector-length 1 exch div 
  vector-scale
  end 
} def
%
% u v -> u+v
/vector-add { 1 dict begin
  /v exch def
  [ exch
  0 	     	% u i
  exch { 	% i u[i]
    v 		% i u[i] v
    2 index get add 	% i u[i]+v[i]
    exch 1 add	% i
  } forall
  pop
  ]
  end 
} def
%
% u v -> u-v
/vector-sub { 1 dict begin
  /v exch def
  [ exch
  0 	     	% u i
  exch {	% i u[i]
    v 		% i u[i] v
    2 index get sub 	% i u[i]+v[i]
    exch 1 add	% i
  } forall
  pop
  ]
end } def
%
% [v] c -> [c.v]
/vector-scale { 1 dict begin
  /c exch def
  [ exch
  { 		% s i u[i]
    c mul	% s i u[i] v 
  } forall
  ]
  end } def
%
%
% [u] [v] -> [u x v]
/vector-prod { %% x1 y1 z1 x2 y2 z2
6 dict begin
  aload pop 
  /zp exch def /yp exch def /xp exch def
  aload pop 
  /z exch def /y exch def /x exch def
  [ y zp mul z yp mul sub
   z xp mul x zp mul sub
   x yp mul y xp mul sub ]
end
} def
%
% [u] [v] -> u.v
/vector-mul { %% x1 y1 z1 x2 y2 z2
6 dict begin
  aload pop 
  /zp exch def /yp exch def /xp exch def
  aload pop 
  /z exch def /y exch def /x exch def
  x xp mul y yp mul add z zp mul add
end
} def
%
% [x y z ... ] -> r
% watch out for overflow
/vector-length { 1 dict begin
dup
% find maximum entry
/max 0 def
{ % max 
  abs dup max gt {
    % if abs gt max
    /max exch def
  } {
    pop
  } ifelse
} forall
max 0 ne {
  0 exch 
  {  % 0 v[i]
    max div dup mul add
  } forall
  sqrt
  max mul
} {
  pop 0
} ifelse
end } def
%
end % tx@3DPlotDict
%

%%EndProcSet
%%BeginProcSet: texps.pro 0 0
%!
TeXDict begin/rf{findfont dup length 1 add dict begin{1 index/FID ne 2
index/UniqueID ne and{def}{pop pop}ifelse}forall[1 index 0 6 -1 roll
exec 0 exch 5 -1 roll VResolution Resolution div mul neg 0 0]FontType 0
ne{/Metrics exch def dict begin Encoding{exch dup type/integertype ne{
pop pop 1 sub dup 0 le{pop}{[}ifelse}{FontMatrix 0 get div Metrics 0 get
div def}ifelse}forall Metrics/Metrics currentdict end def}{{1 index type
/nametype eq{exit}if exch pop}loop}ifelse[2 index currentdict end
definefont 3 -1 roll makefont/setfont cvx]cvx def}def/ObliqueSlant{dup
sin S cos div neg}B/SlantFont{4 index mul add}def/ExtendFont{3 -1 roll
mul exch}def/ReEncodeFont{CharStrings rcheck{/Encoding false def dup[
exch{dup CharStrings exch known not{pop/.notdef/Encoding true def}if}
forall Encoding{]exch pop}{cleartomark}ifelse}if/Encoding exch def}def
end

%%EndProcSet
%%BeginProcSet: special.pro 0 0
%!
TeXDict begin/SDict 200 dict N SDict begin/@SpecialDefaults{/hs 612 N
/vs 792 N/ho 0 N/vo 0 N/hsc 1 N/vsc 1 N/ang 0 N/CLIP 0 N/rwiSeen false N
/rhiSeen false N/letter{}N/note{}N/a4{}N/legal{}N}B/@scaleunit 100 N
/@hscale{@scaleunit div/hsc X}B/@vscale{@scaleunit div/vsc X}B/@hsize{
/hs X/CLIP 1 N}B/@vsize{/vs X/CLIP 1 N}B/@clip{/CLIP 2 N}B/@hoffset{/ho
X}B/@voffset{/vo X}B/@angle{/ang X}B/@rwi{10 div/rwi X/rwiSeen true N}B
/@rhi{10 div/rhi X/rhiSeen true N}B/@llx{/llx X}B/@lly{/lly X}B/@urx{
/urx X}B/@ury{/ury X}B/magscale true def end/@MacSetUp{userdict/md known
{userdict/md get type/dicttype eq{userdict begin md length 10 add md
maxlength ge{/md md dup length 20 add dict copy def}if end md begin
/letter{}N/note{}N/legal{}N/od{txpose 1 0 mtx defaultmatrix dtransform S
atan/pa X newpath clippath mark{transform{itransform moveto}}{transform{
itransform lineto}}{6 -2 roll transform 6 -2 roll transform 6 -2 roll
transform{itransform 6 2 roll itransform 6 2 roll itransform 6 2 roll
curveto}}{{closepath}}pathforall newpath counttomark array astore/gc xdf
pop ct 39 0 put 10 fz 0 fs 2 F/|______Courier fnt invertflag{PaintBlack}
if}N/txpose{pxs pys scale ppr aload pop por{noflips{pop S neg S TR pop 1
-1 scale}if xflip yflip and{pop S neg S TR 180 rotate 1 -1 scale ppr 3
get ppr 1 get neg sub neg ppr 2 get ppr 0 get neg sub neg TR}if xflip
yflip not and{pop S neg S TR pop 180 rotate ppr 3 get ppr 1 get neg sub
neg 0 TR}if yflip xflip not and{ppr 1 get neg ppr 0 get neg TR}if}{
noflips{TR pop pop 270 rotate 1 -1 scale}if xflip yflip and{TR pop pop
90 rotate 1 -1 scale ppr 3 get ppr 1 get neg sub neg ppr 2 get ppr 0 get
neg sub neg TR}if xflip yflip not and{TR pop pop 90 rotate ppr 3 get ppr
1 get neg sub neg 0 TR}if yflip xflip not and{TR pop pop 270 rotate ppr
2 get ppr 0 get neg sub neg 0 S TR}if}ifelse scaleby96{ppr aload pop 4
-1 roll add 2 div 3 1 roll add 2 div 2 copy TR .96 dup scale neg S neg S
TR}if}N/cp{pop pop showpage pm restore}N end}if}if}N/normalscale{
Resolution 72 div VResolution 72 div neg scale magscale{DVImag dup scale
}if 0 setgray}N/psfts{S 65781.76 div N}N/startTexFig{/psf$SavedState
save N userdict maxlength dict begin/magscale true def normalscale
currentpoint TR/psf$ury psfts/psf$urx psfts/psf$lly psfts/psf$llx psfts
/psf$y psfts/psf$x psfts currentpoint/psf$cy X/psf$cx X/psf$sx psf$x
psf$urx psf$llx sub div N/psf$sy psf$y psf$ury psf$lly sub div N psf$sx
psf$sy scale psf$cx psf$sx div psf$llx sub psf$cy psf$sy div psf$ury sub
TR/showpage{}N/erasepage{}N/setpagedevice{pop}N/copypage{}N/p 3 def
@MacSetUp}N/doclip{psf$llx psf$lly psf$urx psf$ury currentpoint 6 2 roll
newpath 4 copy 4 2 roll moveto 6 -1 roll S lineto S lineto S lineto
closepath clip newpath moveto}N/endTexFig{end psf$SavedState restore}N
/@beginspecial{SDict begin/SpecialSave save N gsave normalscale
currentpoint TR @SpecialDefaults count/ocount X/dcount countdictstack N}
N/@setspecial{CLIP 1 eq{newpath 0 0 moveto hs 0 rlineto 0 vs rlineto hs
neg 0 rlineto closepath clip}if ho vo TR hsc vsc scale ang rotate
rwiSeen{rwi urx llx sub div rhiSeen{rhi ury lly sub div}{dup}ifelse
scale llx neg lly neg TR}{rhiSeen{rhi ury lly sub div dup scale llx neg
lly neg TR}if}ifelse CLIP 2 eq{newpath llx lly moveto urx lly lineto urx
ury lineto llx ury lineto closepath clip}if/showpage{}N/erasepage{}N
/setpagedevice{pop}N/copypage{}N newpath}N/@endspecial{count ocount sub{
pop}repeat countdictstack dcount sub{end}repeat grestore SpecialSave
restore end}N/@defspecial{SDict begin}N/@fedspecial{end}B/li{lineto}B
/rl{rlineto}B/rc{rcurveto}B/np{/SaveX currentpoint/SaveY X N 1
setlinecap newpath}N/st{stroke SaveX SaveY moveto}N/fil{fill SaveX SaveY
moveto}N/ellipse{/endangle X/startangle X/yrad X/xrad X/savematrix
matrix currentmatrix N TR xrad yrad scale 0 0 1 startangle endangle arc
savematrix setmatrix}N end

%%EndProcSet
%%BeginProcSet: color.pro 0 0
%!
TeXDict begin/setcmykcolor where{pop}{/setcmykcolor{dup 10 eq{pop
setrgbcolor}{1 sub 4 1 roll 3{3 index add neg dup 0 lt{pop 0}if 3 1 roll
}repeat setrgbcolor pop}ifelse}B}ifelse/TeXcolorcmyk{setcmykcolor}def
/TeXcolorrgb{setrgbcolor}def/TeXcolorgrey{setgray}def/TeXcolorgray{
setgray}def/TeXcolorhsb{sethsbcolor}def/currentcmykcolor where{pop}{
/currentcmykcolor{currentrgbcolor 10}B}ifelse/DC{exch dup userdict exch
known{pop pop}{X}ifelse}B/GreenYellow{0.15 0 0.69 0 setcmykcolor}DC
/Yellow{0 0 1 0 setcmykcolor}DC/Goldenrod{0 0.10 0.84 0 setcmykcolor}DC
/Dandelion{0 0.29 0.84 0 setcmykcolor}DC/Apricot{0 0.32 0.52 0
setcmykcolor}DC/Peach{0 0.50 0.70 0 setcmykcolor}DC/Melon{0 0.46 0.50 0
setcmykcolor}DC/YellowOrange{0 0.42 1 0 setcmykcolor}DC/Orange{0 0.61
0.87 0 setcmykcolor}DC/BurntOrange{0 0.51 1 0 setcmykcolor}DC
/Bittersweet{0 0.75 1 0.24 setcmykcolor}DC/RedOrange{0 0.77 0.87 0
setcmykcolor}DC/Mahogany{0 0.85 0.87 0.35 setcmykcolor}DC/Maroon{0 0.87
0.68 0.32 setcmykcolor}DC/BrickRed{0 0.89 0.94 0.28 setcmykcolor}DC/Red{
0 1 1 0 setcmykcolor}DC/OrangeRed{0 1 0.50 0 setcmykcolor}DC/RubineRed{
0 1 0.13 0 setcmykcolor}DC/WildStrawberry{0 0.96 0.39 0 setcmykcolor}DC
/Salmon{0 0.53 0.38 0 setcmykcolor}DC/CarnationPink{0 0.63 0 0
setcmykcolor}DC/Magenta{0 1 0 0 setcmykcolor}DC/VioletRed{0 0.81 0 0
setcmykcolor}DC/Rhodamine{0 0.82 0 0 setcmykcolor}DC/Mulberry{0.34 0.90
0 0.02 setcmykcolor}DC/RedViolet{0.07 0.90 0 0.34 setcmykcolor}DC
/Fuchsia{0.47 0.91 0 0.08 setcmykcolor}DC/Lavender{0 0.48 0 0
setcmykcolor}DC/Thistle{0.12 0.59 0 0 setcmykcolor}DC/Orchid{0.32 0.64 0
0 setcmykcolor}DC/DarkOrchid{0.40 0.80 0.20 0 setcmykcolor}DC/Purple{
0.45 0.86 0 0 setcmykcolor}DC/Plum{0.50 1 0 0 setcmykcolor}DC/Violet{
0.79 0.88 0 0 setcmykcolor}DC/RoyalPurple{0.75 0.90 0 0 setcmykcolor}DC
/BlueViolet{0.86 0.91 0 0.04 setcmykcolor}DC/Periwinkle{0.57 0.55 0 0
setcmykcolor}DC/CadetBlue{0.62 0.57 0.23 0 setcmykcolor}DC
/CornflowerBlue{0.65 0.13 0 0 setcmykcolor}DC/MidnightBlue{0.98 0.13 0
0.43 setcmykcolor}DC/NavyBlue{0.94 0.54 0 0 setcmykcolor}DC/RoyalBlue{1
0.50 0 0 setcmykcolor}DC/Blue{1 1 0 0 setcmykcolor}DC/Cerulean{0.94 0.11
0 0 setcmykcolor}DC/Cyan{1 0 0 0 setcmykcolor}DC/ProcessBlue{0.96 0 0 0
setcmykcolor}DC/SkyBlue{0.62 0 0.12 0 setcmykcolor}DC/Turquoise{0.85 0
0.20 0 setcmykcolor}DC/TealBlue{0.86 0 0.34 0.02 setcmykcolor}DC
/Aquamarine{0.82 0 0.30 0 setcmykcolor}DC/BlueGreen{0.85 0 0.33 0
setcmykcolor}DC/Emerald{1 0 0.50 0 setcmykcolor}DC/JungleGreen{0.99 0
0.52 0 setcmykcolor}DC/SeaGreen{0.69 0 0.50 0 setcmykcolor}DC/Green{1 0
1 0 setcmykcolor}DC/ForestGreen{0.91 0 0.88 0.12 setcmykcolor}DC
/PineGreen{0.92 0 0.59 0.25 setcmykcolor}DC/LimeGreen{0.50 0 1 0
setcmykcolor}DC/YellowGreen{0.44 0 0.74 0 setcmykcolor}DC/SpringGreen{
0.26 0 0.76 0 setcmykcolor}DC/OliveGreen{0.64 0 0.95 0.40 setcmykcolor}
DC/RawSienna{0 0.72 1 0.45 setcmykcolor}DC/Sepia{0 0.83 1 0.70
setcmykcolor}DC/Brown{0 0.81 1 0.60 setcmykcolor}DC/Tan{0.14 0.42 0.56 0
setcmykcolor}DC/Gray{0 0 0 0.50 setcmykcolor}DC/Black{0 0 0 1
setcmykcolor}DC/White{0 0 0 0 setcmykcolor}DC end

%%EndProcSet
%%BeginFont: CMSY10
%!PS-AdobeFont-1.0: CMSY10 003.002
%%Title: CMSY10
%Version: 003.002
%%CreationDate: Mon Jul 13 16:17:00 2009
%%Creator: David M. Jones
%Copyright: Copyright (c) 1997, 2009 American Mathematical Society
%Copyright: (<http://www.ams.org>), with Reserved Font Name CMSY10.
% This Font Software is licensed under the SIL Open Font License, Version 1.1.
% This license is in the accompanying file OFL.txt, and is also
% available with a FAQ at: http://scripts.sil.org/OFL.
%%EndComments
FontDirectory/CMSY10 known{/CMSY10 findfont dup/UniqueID known{dup
/UniqueID get 5096651 eq exch/FontType get 1 eq and}{pop false}ifelse
{save true}{false}ifelse}{false}ifelse
11 dict begin
/FontType 1 def
/FontMatrix [0.001 0 0 0.001 0 0 ]readonly def
/FontName /CMSY10 def
/FontBBox {-29 -960 1116 775 }readonly def
/UniqueID 5096651 def
/PaintType 0 def
/FontInfo 9 dict dup begin
/version (003.002) readonly def
/Notice (Copyright \050c\051 1997, 2009 American Mathematical Society \050<http://www.ams.org>\051, with Reserved Font Name CMSY10.) readonly def
/FullName (CMSY10) readonly def
/FamilyName (Computer Modern) readonly def
/Weight (Medium) readonly def
/ItalicAngle -14.04 def
/isFixedPitch false def
/UnderlinePosition -100 def
/UnderlineThickness 50 def
end readonly def
/Encoding 256 array
0 1 255 {1 index exch /.notdef put} for
dup 34 /arrowup put
dup 35 /arrowdown put
readonly def
currentdict end
currentfile eexec
D9D66F633B846AB284BCF8B0411B772DE5CD06DFE1BE899059C588357426D7A0
7B684C079A47D271426064AD18CB9750D8A986D1D67C1B2AEEF8CE785CC19C81
DE96489F740045C5E342F02DA1C9F9F3C167651E646F1A67CF379789E311EF91
511D0F605B045B279357D6FC8537C233E7AEE6A4FDBE73E75A39EB206D20A6F6
1021961B748D419EBEEB028B592124E174CA595C108E12725B9875544955CFFD
028B698EF742BC8C19F979E35B8E99CADDDDC89CC6C59733F2A24BC3AF36AD86
1319147A4A219ECB92D0D9F6228B51A97C29547000FCC8A581BE543D73F1FED4
3D08C53693138003C01E1D216B185179E1856E2A05AA6C66AABB68B7E4409021
91AA9D8E4C5FBBDA55F1BB6BC679EABA06BE9795DB920A6343CE934B04D75DF2
E0C30B8FD2E475FE0D66D4AA65821864C7DD6AC9939A04094EEA832EAD33DB7A
11EE8D595FB0E543D0E80D31D584B97879B3C7B4A85CC6358A41342D70AD0B97
C14123421FE8A7D131FB0D03900B392FDA0ABAFC25E946D2251F150EC595E857
D17AE424DB76B431366086F377B2A0EEFD3909E3FA35E51886FC318989C1EF20
B6F5990F1D39C22127F0A47BC8461F3AFDF87D9BDA4B6C1D1CFD7513F1E3C3D3
93BEF764AA832316343F9FE869A720E4AA87AE76FA87A833BBC5892DE05B867F
10FA225E233BCFA9BB51F46A6DF22ADCEACC01C3CD1F54C9AEFA25E92EFAC00D
7E2BA427C25483BA42A199F4D2E43DFCE79A7156F7417ACF78E41FCA91E6C9EF
B933450D851B73A6AB6AEA7EE4C710CB5C14270D1674FA334686653793FCB31B
491E870D3C2BC654D2C1DE463EC9BA29D7371AA1078800EF93D3F66263A2EBBB
F5723697BF7448BD0D2E301544BECF497FD475B85DFEF52AF4F8F8BE445CABE6
019318806D10C5952157FF8F8286C1EE701545C8F60EFA854EAE66835A2046A6
915D395F1E0366EFE0C0391583FE001FF16D82A2E2DA5F57754A2C6F69306E36
356ECF8EFC3F1188AD6FCD2427E0580C97A5B69B4E0E09B85EEDE142F5ADD2F0
5DE51D6DB72B127412A0D57106C19CA493048A4F815129ABE767D51715B1515D
9C21067CB5BC88741B7298C83EAE36A866DFA87D8981F179B1C31292F56BBB64
3C430779468AAF07C8A8B4934E1E775FE3F35186BD1FA6EE3689C1C750678AF1
FBF9B23195A124C5C991FE670AC0C86FD39D2B07B9A319E74EFD498B45820252
720ECDF7294F7B0B137CEB86D33BFCEB8606985A3260FD669E461C8BE94216C5
D434FD8854F44EE66E5A289A9F9E32BC36AF645D53F96652602BAED418C8D726
BD04A1B4617551FE4DEF54083D414F7DCE004E6BB2DC9C2EF7CE232B254BA2C5
7DCBD36C2072ED46FF711F121A701E2284BF1B718B3164382B8F453D68FA0377
DFE106503B8401D4DB87F5402A3AC9A442FA060B0610A9524D530C7157C26B56
AC970FCC1D5655FFFFA39246E6420CF97D08ADFB7B05822679BD40C638DDF0E7
A97BFE8918B611A145AC965C203F1428812F9D340AF499B3A915B22BE798594E
0F520109FC81E452180AE45B170FF999C5FC2761C6CECD8742A5A6FC97F16743
AD4EFCC6572A6D3F3E4E330C5CB2FF6FEA48A5B64DD3DBE943BD9918D4A18E18
CBCF598AEFBB6AB3CD2CBC9BFD6099272F6543F3E532E0E21E614BD2880B1023
0AC234CB705827BF016DB84E00E8C255FDEFA0101A842929540B7B4AA8A089BD
5EFF05B72356B6BC3727817823B5CDBB1B963103000D7F2A4E2A1472FC3E614B
5CBCB6D6D784023173DEFEBFA8F9ED87EC1A0A9EE98CA59CFC964CF943DC683F
E9E00DA718C4425A705A69D99988EC6F152525C790912C2E46A2381A569424AB
54DF4798BC2D7E7A361E7991641D4B756CE2A7FF4A2848927092C59C2C4B8809
E13AB84FB6B111E680D7FB9F2FFC2C5C66B0B501E4447C2E46C10E2F6124476F
A140C404CFE2DC9E0199BF61E035CEB481D438139A9630934E541D261FFD2906
4CAD99E20655FA746AFB81EDBB5601F5FD6B1D6832A01D585E2C55053F6A7378
4DAACCAC7608DBDADAAE732D66B3E7F87E79756337C1A961E53A4651BE7C77F4
038B89C87F650C54A2A90EB7F1D525BB353F33318551EE8D84A6A83C718EA5A4
B2AC0F7306B1E095819B87015A90CA3ED739B09061782C28CDB36BA4BD5E5308
5CBB70414E4112193DAC4A1FA30996327230D1E021F3CD8115E12D239D93FFDC
B645910EB29E40D830E7BAF2DB255FD7C4E776557BB38157917D993EAC245837
A3B515147043574157B8342D829C7228CCEA843ABC89D1785A9672A5923FC4CD
2F3FF27E6FCACF84E2D3136CA2C0FD3EF1EE7354CD04C38B5FB874553646ED2D
CEDF7E362EADD04B18051F20A8FB0DE18E152385B9D05F98A3A7EF177824E246
455ABE69E2F700EB78185CCFC07E3B4C6FA301112528D977367D30D0D5D59EDE
FAEB706DDC970A9E296236C725B2B55B09B9C336B8E23CBA5FB8692D56F33B03
16294E5FC7FAA42E96395A57CE51CA8DDD77442F142E2E576B778373FB31C81C
16840BB422CA827E30A81829648BDF1CA36700EA32AD888D097C1FE0A05B2D9F
483AEE40269DF09AF0D1AD3DF80C45DDC59C2A03FBB661C79B87853737C6D352
67626B657321B16198DBD6DB98A092F17878AE4698121E1006E53D6F9B0A3BE2
3FB68828EF854A0CDBAA68B37ABCA6AD4A3D809AAF0BAB1697A81FE59C98C472
1E33CD70A75A22C249DD11D76C2575ED3370A25892A16D2FD569CDA70C130770
93F493C7D47D6F9A5424A7A542BAD726BFC3AB225DCEBBE6AC4BE006F8C7C0EA
051424B08305BF2D951AB2986AAFEA04E078CA79B399585BFF0F1ADCED02E15B
8765EB6BF6A8E4D0901EFF2C3AA104924EAD9637A35D877E0C51A3C37DA78CD4
8643C8CE6DCDDE3F116A6C2390F948E5371BEB5AD2E87B41C5F01FB5C196C436
6E256A88D082E3F46E4EFFBF605B2EFF1E9D9AD5EE4DDC323A137CD9451EDEE0
06F7D82898D71FAF2362C0FCF1F726F97F820305B7CE20728CA08C63575083A7
84BA28B7DE2B916432475510E274C12FFD1660A717F51DACFDF0A102D85224E0
D6DB607BB72569ABB8A7BC6A10354CBBC01732EFE35B72062DF269CB25EA3DE6
DC603B04C90C5912D2C38D7A5ACDCDD3F6F116D884F0D8C528F69D5D47BA20DB
0A9E585C7D8CC3C324FE8A1DF150279F7E8FB43BDB720E624E5E9918032C02CD
8020636AE5C38DA2484B7F4B34163E0D0A561B43B80E97746DC05C871AB620EC
C5D47101ECED4A7E25F291184BEF8B80024AA7BB456C1B83A907652B331DEA34
754226C39C6889EBEEFDAD081E01EF8FE47751987667836FDE4C8BB8A3FD4406
1E643B4EA37BD370734D1A2DB17C2F4B74B4ED75098B433601F75A88C9A37A05
CCB157EF6E32023BFA33973F3E655A4D58289136996FCFA61EEABD70791B6523
1FF5DE71AB8A17038923118A5EED8D59C4C58D246FFA9BB26472346B40C8741F
153D19CAFF20DD2A86C6DB89154A630FB1761929FC3F0448EE2F089C1C953E02
905BA8DE75D101A982A611056C4B237596C10951DD98BAB838B742D3CF7DE718
617DB72E5268583223E37E029D1C8FD3F1D21690151F76B76C52C725CA135CA2
8666553E863CE188BFC9B99AF56AC2DB5BFEBEB12FB563D00244EB89E478657A
98AF2E1223C1ABC25A4500E8119B86EB3C26B8A2F3505A3E5610F89B7C34E278
53FA0A54A7F46D84A35EFEC36AE660A9E3C37EE3864106702DE5AF6C45ABF64B
888A4A51323138CE77DB935576FE6B4824B6942DF80625098CE1B5B32B234F1D
052A9D6039697118A9D793793775D8729D8574A2E74D7109C7B7E23BC5E2E87A
CA8E019203952A4892544E1AD3D4EDD22971611358AB230E9A2ABDF00A288501
A01B67C42B33F6B78C39562DB50F4663B922D9BE0D8A150311AE44B83C1F129F
07337323E9A23211EE58E16043E127C6F9574019179F5635648A011266677B56
B5D0201A4E1470B952A1579B57AB2329CD4C615395023C653F784D36B5EE3672
10D191F29EA508CE84763CA4CE7C2C5229E38E241255A5CABCD6C7CBAED901A2
CA53B5E24111921CDDF83578D33D463D70EDACA0E470D8F592303FB6BFD68B4D
3F3BE2D7C5EC8BBF10C90111A33E205F2649B56E8443F6FAA6C721C66575AE12
D4C40F1F46CF9E9DA675AB5D5840D938780CD9E4AD6736ECBEB6A4397613586F
849B51048AC5F9405E03E14540A5E5582F61CDCDB57EDDF95A8C6705F433EE16
648F098C03DED8A2AD94AE3DE202D629B9422ABB031318D48F2C85F9DBFA17BE
84708AA3B6C9F81F4508F7A5CB7B6646AB8722ECF817877B77D473F577556DAA
2BA0ABACFCF5DEA7498C47328E873019A956FBB250FD9D8885D21D368FA70CBD
2709D2DA44EE7A9869963EAB48789541906DE49FAE785ECE1F18A22C7E7ED204
9768896B78E9EB7A2BD6EEC1B26083940656ECD689D92942CC8AF05CBF82AED0
B45A7DF4DD7AA6526FB597322560B9ED3087A65B5EEF1371C328A021411BFE3B
D9B5088B2F1AAE381FFED52D2D1E02CD0DA78683E3B06171CBE94BE9760005D7
135893D7CC2DB097F6AC664D9594CF1C650F84DA80D2EDE04802DBA33CE3DAFE
EB7A37E8AEFA4FDA6252FF21E8673DD98E67124D5DBC7BACF361E57077B71939
C1D1FB923E4E35C075CD1BCBE0E80DAEA1320D55B43EAB45D9B26C366B278782
7519FDC482D98839BF0DF2E7C3A56A1C1A3FC0E57A75CA414F6536C1FE8EB7A0
4ADFEE3BEDA0F53BE8CF5F64230784A797133E8CD46BCCB3BF38BCE38A73CCE2
9E073ADE792F7128231DDD1F63E6156ADB2609C200837C2E8A2D93D2A7BC9171
050C709A71E44E32B1B03C92EB5CF1D3BAB1C38E027DC4ED9AED633D98CD7486
3F773ACF8AE332631CF2ABE6D606607593FE862ADE31803964E3F4DC3CE3A271
C76BDD95C87CDB3B87BC26FC7A16D567EEC62E6FF0D471B4853DB8A94D4CACF8
843824F818083F10E88D52FC4253E8203292CB40F1414AE7E51DD7347007C342
CD70E8E9F2D2A13D71213B841DDEAAB208AD9EA644591C15DEB084165F9DF24B
B91D3BBEEC2E34E38EF16A0C3F00700A7BDCBBFED2EC0D09601AD6538288DB50
3478B051B5E16B604A0341FE621A58718D960D699D3FAD284310DCF54EB13175
19A75A539EE98E804AEA24689D3540F0F12951A3C01FACCE9A7BAF4D0DAFA946
FF65A4D2A4C39969607272C6886F44E90ABE27CA3A1F12A29D9B32E60E8E34F0
17C5FE43D0E69A99A922D98909B2BBCD145E59A5E7F5426B3988F73B09A525F6
8BD4915663C1301323180E760BE81CB874B020FDA3AE63340E4261E4F3E4949B
CC0966BDC4426190BE9F5D77F76A72AD925662E5FE1CEF9CCAB68F0BD33DA003
F11EB91AC4502FBD6AE48DA0F9D07C35B96B103E379B8A83A05FE728F1716194
1F650F75BEBADB2E3810388F3E2DC7B19F1BA9E32925F2FD9F19F4E8701F3E4E
4069125D7C401144740691E7A460021A47B1E27997FC1DDABEC5BD0EE0B20194
2D579C7D6727AA124083242BDA46D8E116E2751C5F298851A62B60AEBE82A929
9B9F2492BA35690D1EFD16215B8EF14E7A3803B93C28FA41D971B05B6AF3B593
E74AD1E68A5FCE12A86E63B78BFEA87D3949FD164F12277A4688BE96356791CB
8671C49365608F3EDECC109321AF92B4C29CAF073DA3A7D73E913D0D83FAC5EB
BD884D4C686056404DAAAD6F82F94F803FA1FB0DD8908D1DF08FB87A8BB83027
04DE0CBB1C6FEB6B517FBD7CF065120079E608CE41893C2BC96A347826CCDFD5
C69E161217F2127A59F1A6F22037641613F191F22D5B4CDCBCC2EE5615623404
ABA7BE6C5FE475481615B2AC1A2412E54688DD21E44CC9AF5F16E634AFCA389C
4D740B7B51BB141BFAD1080E7C726C1606A28ED492E6BDE9F800EFACD1513909
84E98CEB6A0B7A2A6F3E1D1DCC3B2552795E0932673E59ECC56DDD37A1D52BA6
C3F0E905978AB568941A163F4CE3AAB5C5B16F86016EC47BA6F3F7AAAA77C3B6
09C8C3ABDB6D514A76ECD37C37AA88B5860630B3406B494F7725975596F84777
D9CF48686EC9C5DBCC1D78513F591C7C10AB9D153B3D41426B7BF668B0D04503
56BCB686258462C1DC61095724B9F3312316262FD7C1AEC6E54DE7E5A7BD8EFF
035299B8FD8A4A7B0F51404F4A760F4D8B4C0FB7A32FA4B2383AB6E9C78FDEDB
FE6A5788D38A6701B123630C2A6D820A684166FBBC83DB17069494FBD411B333
CB37E2491C5BD035A33867A6D3A3D420CC31ACF43AA07182CAAE67E40EC63663
B678F71D4C6E0EC3A0AAF904CD3AA66E0DE5E3CDE049E94249B39A1C06E3CE9A
F974B2484BB2CDA14282B9511E505B3C89F9C802218AE40D1A7541335C5736DD
CD565D4B9F4CC78F3A393737EDB4FBD0DA299E21CCFEBA5478EEF013F0552A8B
0BB11FF46CCDB784E8BDCF730A16363E66572049E42C695886EAB42A9AD9094C
B635DF4B5B9BD9B9AE8455DFA3EEFC77653190F9A8B1E93B7281C2A21EA7DDA9
33484745BDF7E3DD63C7AC66C286C9A5A698A5E4D7A91710B7FF943FB23609B6
4B442F83CB795788FAB5E9CF3F75D5487DA26170E4561C7941C910B088C3B86D
F844B0F340CF82786A3FCF347048463EBD2006281A816627065DDA6CD4D3AC5E
2024BC96C7D896381BBB567951E7A1F29D4E95351298B000D29E5F3D0448CB5A
CFDAE1BADE9403B90371C3A07D208948AFA022A69C519434B6813086ADF518D5
88E0B92072A44BA1B3EBB630A13B7AB90992E85B6D67361C8D96F3E0D826FF37
17B67E4B1EB7BADFD98D7F4FD17BECE740ADF13C141EBF0A91CB105DABB32FE0
55086D56A0D358841D15FD349E6B95512E4EDF4C430216FF85C2ABE995E4B40A
A6044CC8820AD885C07E052B3F91C2E9A1D163BFFD210F7BE95B923E2500DB50
2075106DB541C267BD450B25B670CE80BCD068D4DBFF2D82634175B61FBD3BC3
406131F44C7D6F18D375D1F2270829DDF29DC14DBB58A30AC193245D18DE91F8
AB88AB548D8138605BB5A50073295534E314366E26665AE70482B890E4101D6B
60E4F3B37ABCA1346DAAE8FDB8DD9C832EFF3E73BA470E2BACE7B8515CB43388
C27AF99FF9322175CF8D4947E6B3846AFF5163E972156847F58A66660EC8A3A6
5FB47C9F637B4CBB4C73B6A080B0CF6FD1E9665E92032540570FFCC747C67C50
822811AADC404BC7ECD1673E8AA6C3A2F1D82F39430B58C29145E2F1B679C46E
94EDC711883F1E4EA84117A54757E8895A40401A26E1437B39A2F65CAADD6E02
D71FA8AF7453668DC613F326A3344F74AD7AC67569AF399385500ABDA5EDD3BA
343CC5EDD4B558467626850E752B9959FEF1454E53E7A3DCBC2255AD8F6AB4FE
894455118A61C58840CB68A925ACCAD75CEACE863D806916228F0614191A1CD5
DC9BAE256018615AA3725834519449B0A88B4F396654E74099C007930ADB1327
DD119BF799FE3B0B223E1EDA04FE2DA7A1C879143E1C33B6C6344F4BA033AD6F
8E88C33DEF1977796B454BAB2494C930F492A518E8198C708A75FFEF8C49C324
A718AB59B889DED521229E741FFE53F98EBE88B0405AD523254FD3FA4BBE96DA
DA1C27C1C979A0DD4E61C3B1F4C4DE01E42F1C4435EECFC02D97994BC8AF5270
E7CB1458D76ED0229C5FFB4A23B8716018F9050970895D51722CDE8F2EA3D947
DFF374D84915D5C5D16463A6FFCD079D1ED416C4347BF831FF0C4ADFB61295DC
4D5785BB0852BF472CFC97EC174491CAF961AB90629F055E75DAA6D9898E8653
5BCF379816CAE46FEA62E7BE8E9B953466E51828172C4DBD0E1BBAD1CE28B5B1
02B3E36403BE80B49A47446A6677FCED438F01D60EB10F478C89528FA337D0D8
88D3FC123C076507ACDAF783A9A6E24ED73BF24B6E0F11C13E532DE5F70EB02A
60651FC2E263002D3986B7B20CC2AA08330B9FC2E26765CD52266969A86EE30E
71E0B41B6C1C6DA423D3A7E1553D2FAF26EF40DC183099322D362E4965695C52
9FC3E5BD7ABD743CDCB717DB10372A722A39CE53FABB454EADE2179C4CBFC016
A8E893C28EF549CA1692C8D8ADFC471DCCDE266FB4E97A1F3035801F3F034D44
AF3863EE8A24A003F07FBF0DFBC12CF2625CE95B5F1C575C28144E1D3C8CF5D7
6D071DB7562414E228147876D45EE47787B7D28DDB3AC6FBE2DB836CB4A4CEB8
BE373048BAF03211D151AC89B84D3174F92A7BC9D676A10BDB22D1F359E271AC
34CBA536F2DC3226B0482387392B1EB52A2DFD2D729B7B1C0FBB2D1D1025E334
CD30A6CA7B999B5E47440DBF9D56A54A022ECB170B4C9B28E49BE9104E482C8D
7DE8EB809CF14F546A39AECF7E0D7678AB28FF15CDD3D456E61A83AF512D575B
D8DC12D25D23EF4D2190A0AA0DA1206DD59F4CB5511FBA74CA25DC8612C1B066
1EF2BDD43674B24E728A7EC156036C82222C3EE6E61AB88CE75D1B2F04AA8F3E
EE0E6208CE688316C5A6CAB473C8DEE4CF5EEE536485791434284A5F6C08595D
6946CA9EA69DDC4609BDBECDE32E87416F099CB43CC805EB2DF6FD90B720D8C6
8E913646EA3ACD85670A2343215E572DCE808FEA7B93B39B5BAF21E5659A8C67
104328DBEB40FA1154D1D84D6A7F4C75AE4850C6F2430DF219FC610CB42A3A76
BD11643A46D86447F0CA9FAB16A149515BAD8F16D1A0B1C577F99412ED4D0082
5667989FE076FBB17A0AB270CB50A00CCD
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
cleartomark
{restore}if
%%EndFont 
%%BeginFont: CMR10
%!PS-AdobeFont-1.0: CMR10 003.002
%%Title: CMR10
%Version: 003.002
%%CreationDate: Mon Jul 13 16:17:00 2009
%%Creator: David M. Jones
%Copyright: Copyright (c) 1997, 2009 American Mathematical Society
%Copyright: (<http://www.ams.org>), with Reserved Font Name CMR10.
% This Font Software is licensed under the SIL Open Font License, Version 1.1.
% This license is in the accompanying file OFL.txt, and is also
% available with a FAQ at: http://scripts.sil.org/OFL.
%%EndComments
FontDirectory/CMR10 known{/CMR10 findfont dup/UniqueID known{dup
/UniqueID get 5000793 eq exch/FontType get 1 eq and}{pop false}ifelse
{save true}{false}ifelse}{false}ifelse
11 dict begin
/FontType 1 def
/FontMatrix [0.001 0 0 0.001 0 0 ]readonly def
/FontName /CMR10 def
/FontBBox {-40 -250 1009 750 }readonly def
/UniqueID 5000793 def
/PaintType 0 def
/FontInfo 9 dict dup begin
/version (003.002) readonly def
/Notice (Copyright \050c\051 1997, 2009 American Mathematical Society \050<http://www.ams.org>\051, with Reserved Font Name CMR10.) readonly def
/FullName (CMR10) readonly def
/FamilyName (Computer Modern) readonly def
/Weight (Medium) readonly def
/ItalicAngle 0 def
/isFixedPitch false def
/UnderlinePosition -100 def
/UnderlineThickness 50 def
end readonly def
/Encoding 256 array
0 1 255 {1 index exch /.notdef put} for
dup 68 /D put
dup 76 /L put
dup 78 /N put
dup 83 /S put
dup 87 /W put
dup 97 /a put
dup 99 /c put
dup 100 /d put
dup 101 /e put
dup 103 /g put
dup 104 /h put
dup 105 /i put
dup 107 /k put
dup 108 /l put
dup 109 /m put
dup 110 /n put
dup 111 /o put
dup 112 /p put
dup 114 /r put
dup 115 /s put
dup 116 /t put
dup 117 /u put
dup 121 /y put
readonly def
currentdict end
currentfile eexec
D9D66F633B846AB284BCF8B0411B772DE5CE3DD325E55798292D7BD972BD75FA
0E079529AF9C82DF72F64195C9C210DCE34528F540DA1FFD7BEBB9B40787BA93
51BBFB7CFC5F9152D1E5BB0AD8D016C6CFA4EB41B3C51D091C2D5440E67CFD71
7C56816B03B901BF4A25A07175380E50A213F877C44778B3C5AADBCC86D6E551
E6AF364B0BFCAAD22D8D558C5C81A7D425A1629DD5182206742D1D082A12F078
0FD4F5F6D3129FCFFF1F4A912B0A7DEC8D33A57B5AE0328EF9D57ADDAC543273
C01924195A181D03F5054A93B71E5065F8D92FE23794D2DB9B8591E5F01442D8
569672CF86B91C3F79C5DDC97C190EE0082814A5B5A2A5E77C790F087E729079
24A5AC880DDED58334DD5E8DC6A0B2BD4F04B17334A74BF8FF5D88B7B678A04A
2255C050CB39A389106B0C672A1912AFA86A49EFD02E61E6509E50EE35E67944
8FC63D91C3D2794B49A0C2993832BC4CDC8F7BD7575AD61BCDF42E2E421AA93E
3FF9E4FAD980256D8B377043A07FC75D6169338028692CCA8CD1FE92FD60AD26
D57B7519B80A8F8DCE9CEE5CDF720AF268D3C14099498A843D76E3B6C0328F24
D36EFE7F5C4E5B5C612786200C8DE3A41EE5F1FFAF4097653CFCDC8F4FD32E0B
03EDB3E413283B9EFB0AC33B055617005BC9B0057FD68C52D1B0E67F0C571685
767F2AA85ADE4E0104A1C777733D5E318A22A9944336E5B98D965E50D31F357A
8B6EA5A0EA98E1B027CE68C2EDB149EDDD04ED74A1B3D206D471A0C11C11449B
DE190BBFEBC08C9E1B7513B43DA3134D6B11A2516E6E86B67F68C970A320D05E
94FEC57FB347606DF89989C33482BD09D011C55AA920319E7B26A205D3D0F004
22466F09C0482A164CFB27EF6ED2B040ECCC3DCAF345B5A73676F193D43123B7
72FD6CFC5E37930E61EBD5A6307E4DE70194E6384EC0D79DB6AD86D3B319A31C
8B0589D0FE28241D8ACE280D0530EE99C80723E560BB72AE9D53F4713181F491
344B06D3027BA4E9E94D4305BE1D817197C54C8FF56CD6964165F6448ECC8A8A
64B48B4F0FD69299A137589E2491A283509B21A3A5772F75B7602A9F60AE559B
07A58436D04222C73EAEA72DE9A5A441F88D27C11F4F91255EFE280E91A4ACAC
1E98A4E5E6C57B9AE86FD218C3CD8F24A4104156A80F13821384E529783C52C8
78B94AB3A0096090867ED32E8A30980E737922037F75F062BD83BF4F5929BC51
CC22AEE2DBBAAA001CFFBFF41D258424FAD888FFF1BEAB796A44E3126159E120
7E4025C676CF94888A1971AEF8B6764B3AF4A92D36FAF6FC56FD049710EE3782
BC2CD84FE2473F133BE03C1346B875463F126DCAB15C7A9BCC9A727D23611462
4E8D2BFD2466600285D79518712B8681ABCD69608E6AA9578F7BD771EC36E01A
5A17BC17E375020ECA59B43790ABEB9DF5F4FBBEF807E5699EFEAC563E1ACC5D
EFA336E75DE6D8248E9381BB110884FDC89C2F9A41EBBC9A8A1F98E6A41F68BE
EE30E25CA148C1EFF42DFF8C214A6537AB11F260B8C329A4947B5FC8DC9C5622
4DF7BF4FBFB00380D47BABB03BC30627AA74103E553F55278F538EDD8C1E64CE
0F1398CA0AB5A86630139B4A7E8FC02804CAFF3830114640AE50D2FDA3B561B5
C63AD7EE3347804CBB40FB1E77A6C89735DD870351C3A1811591AB493251B904
314F65791963C0412377C1D02362C5E9655F1C3D4803CD379A8EF24C48218C2E
DF1165840462BF37DDE1B8D5FF09FA2C3B261E2F1A65ECFBE5D4EAD43B52C029
EEB3948CB8A252CBAF545C8FA1C31E920E23A12DD7222CEF2D2A513BD758EA13
DA33BF5FBF1D734653EB83DA2D374A5B9A0CE316F24EE375D6DF6BDA49954C2E
DB25A88821193636119D469BA66E5DAA9C92520FD4F84426A4E54273FA469084
7517817A6EE3E21176D333825E88046F50B3CF6938AF9BA79A2F51398239EB91
1A2D07F7FCD948427FF62F40FF95E39FE1A1AA8451411563FD5388472251C155
69BDE9283B41900B21EB1190D06E6B13B7794FED020D2C1BDD205AE77B084BCE
EF628249398B496DE85B406FC2E1939EF00DFC84C07E26CF72EC401BAAE756E5
7F6673216E7560D1C2A723CB405EE5CA474A07F61B81F8836482F73DC9516D67
CE0CB770EAD755B6B356198B4B97EBB29C63456953270CCC8D5650C1D006E69D
38DE2DFEAB27DAD50A817F0D645D30AF5B75A7B53CBD3D2B8D87BD0A7E525AF3
22F7ADDFCE31716914C2318260C2E2B4664893921B68C5A93334A361D94A759C
0D7B146D6FD94F0442D672BDA0F6432E18F3C5DFA37ADA378D95B75F413C9ED1
BB5C606A3EC7DFB3F796F59B0478C13FD1900381EFE0BB5242D5B5D34D03AF1D
4BDC93EAF8020E26CA23C8B0E7DDEBBC6762A557067A4CE05A524188A8F02E2F
3625DA38DFCF381727887F5646A3995A8A38A5FB1E5D5EBB395FDD0B7C8E71AD
B48EEDB62AB2CE99D121435EFBBFCEEA69AE9ED8238B60CC7288DE33C766CDFE
15B767B4AE2E6CE0965E77272AC9F86023DA620548CFAC85BC751C44218A29C9
849F1C2DCBDFAD895B54E51A569952ED50F82DC8A19F367E7E44643854EFD6B3
FCAEB04E55E4661C82D31E2932611748480EF61FB2FBFB0CFB940BEA81AFCD84
4C6A6332D7A600170E38A8EAFCD4F93DC153C43175434C86BC747348FAC61B76
1FEC9027C1A193E55C80F1F20B5317AA0A05AAA36AE235F6E49F06E570FEE798
84857D7552EA92EF3EFAD52DE39C2F8F43C59E3A957B7B926FC95FC4B60186DF
7F3523EE2AB74E294C8C4BCD8B4975E84849E0FBDA6C0B0F24A636DFA578B122
CF97BC5089E21E9F5298D1C9F30CB8BAFF6A3A11BB4D9A0A5CF2B18D055C44CA
4FD4D8FE1AF3630907DE7E585AA811F9CD11FB2C8FC791851D651009FA5DF20B
3C33FD2FF848A9E3F5652BD294965A332DD3F246C91B0ADA34017FF2451D1394
F9C3C95AAC6EC8062BE98E8914D51DA6A164AD13938693D446044859D03A949D
F9AC5DF4A000CDA98BB516D762CB9F6D44B5268FD0C26E88BC4A760C0F75A140
DEBDECA4F511128B7D2805872160C55236F0A0FA7637FF0D4E94AC079CD3C8A7
D03A5A56F26B0438B577C46011A10532FEBCAD14FBD6032E224F45691A726886
56F305231EB2FCDF59C8BBFCB5DBD2D093A0E84D62AC93A2312CA69295E937C4
8DBA1802B85F54B5E7E6D6216A918F911FF705D3B5CF055F1D873B96283A0B53
59344D910CD396D883F6F7836BA65FAB4393A773A8F6BC298069E5BA38210EED
49C9D920F718E3FCE692527DC7CCE6963BF744F2C91BC5952564196D60574E86
87A0FAB21F2DB2BD5A51D7FBD8FC19946D24E5A228462C4772F978E650ADCE3B
8D66B9C21279C531CA1C3A8ECE3420BB65837287A7222CC3673A2A5F8BBFDB60
C719CD073EF9A23675198462C7C87B24CC92D6AEE5C25AC63855CC3281494342
D28F3D2FDE0C183486769A4FD5B0143193D31FCB2C2A14E487BBD96D0BADBB64
D1B56021C363A795BF10E2DB448261C363A54A4AC1182B470C457AA82DF3F5D1
F4B329806141EBD53CAE309319B94133D7EBDC2D0453A905ADD207364371E178
0A95C2686E3B34C4A978BFC0EE968C39ABA00889BC5149162C2B54483D44FD3B
5CFF41F611C7E03B94945F414560E874D7CF27FFD0630890D7D7EA66CBD15448
229059E1C436BB33D69552B5367AB5D53591C4678D0C704DD3EA23F5D9E8A7AC
17D003C19E333E726FFFA2961F33C70F429085F7BFE3E2510F59B78F58B19CB4
01B48E184BAD9020FECCE3AF52048A056981DAEA02AE78197E65855DDB170616
F54278395D9EA50DC83761AE759F9CDEF9E1948E7002414FC05286ED793E6662
3347F2A9AF8917493D7305B92CF93E8E9185F70015F5594084298A6C2F9FD3C0
689F262AC9FEDC9B89577ECDE92F08D3142209FBCE7B5C0A840CC767BCA56C20
4E4E545E2BE4D21C53855CEE4CD0AB35D1A604C0FFFF77DBAE4289752276559F
A05FEE65F45ECAF44E95E23FAB6052195C7948AF0B1126482D4E02D72BF8AB03
DE0F1A632F7672AD9DDE70EDC82AA993678A82BEAD0BC2649C4707FD8509810D
364B5C6FE0E10772E95288C622C2F06C634F4DF8C7FD1432BC9310D5F24FEE3F
7AB324863D6DABAA1576E70643CA79EF4D7DF4105093D66CEE0F3B87D2164A7F
26EA05F5C4645B22D3E1BFD2219657712C168FD90DE801FB0F32759E80DEC1E1
43CEEB19FED12D757205043FC98FEC62D6A8D8B97BC083B4A0E985AF7850D6FD
8716B9957C1C35A0675BC53DF672C425C79F43FDABAEE7D63F092CF271C9A9D7
C41F40C4189510987887942E60A412B3EEC84C9A6E1AC7D54D528F5604B72C08
94B7882621A5BF1F325B92FF96B80878CC550D1AE4D8196E41CB1251856609A5
C4D3BD05A922D0D45E039D9450DEF8490A3E924E41434194910BF60BA1B08BE1
B41824345627745541A4F1703E956328F6227D11C74946B38CFB096139979E56
4E723B889B44C6D78673868C89912F8B4F0B4B485F1587A637B630F92E6072D5
7F3B44EA6FD96BBD4FC28A6C1D90805E3BE3E42A7BC9C880762966C55BC04E01
204D083AE976FAE6F37C94F27E68F8C0F28D52B17F6C0FD7C9150701FD78F8CE
B8E8DC9260E3974005EB5CA728171F482D765016C94D4ADFE4A42EF42212BC56
7E4EEEE8B0D2A7856CD4E44F55C0BAB762F92CB8D64C17022D4BF3A47C12F5E6
279FC23101FEE93753653CE8CEDC3B75C9CCB29BF1D4554C6120DE8EE750FCBB
E38B5D915206974962E320362E59B3F21B3AB1875703191043D03284D4467346
CFF2F98CEB4845B73ED8E003E0DC94251B73E13A9B51A3F1430BCF6A21EB9B7A
65E17FA411F53BE6432F1506232B8159E008FA257F884A4A01AC53BE91754D78
BF14A5B0FBFB9C31BF4908355F8A762052968DF526D118708CCB0B7CB5BEE285
6DAB6CD2E3934178E60BECB11AAB5478623CF6C50C92F8BB5D1A583609028FA7
B8A53B791BDC9EF76A124F3F7641857E4BEA0837CB36176EC9A522EA7F41B8D3
63C37D1145367BD300F17B54522A834BBB74DE12BF9EB26ACE6F24A046D58F89
4D4B7DF74875F1A0C1C9D97BE0849593D7B398EB4B00BEBC8C8D1497B6EF831A
A35380FFB7F1AFA4D888AA52C9482E8B1755CC209905F98F40D95B44D4DCBCB6
67423D1BC2F3560FF0A8B4F0CAC352A4EE2C1D946E45AAEC8A6AD40303F3382C
DF0756BFA3B1ED64C169E56ED1C760F2FF0E24DC5C9F41306EF8D2628153D30A
5DCB0791126BEFD4947D7EF08301FE015F2B0008DFFCBF9F2D4D859FD43EC7D9
C5BE237E9BF6665B7B1BEBB362F0C0C3A8D86010B9C97FA741C97C2E0513386C
9C26C235B14DD2A58BFDAC7B5F63DB4DA6D5D37D0098175A9071590E1DF66A3D
B8173A047C29D7D35557F06132CC920B5460B8AFC11D23D09A4E45D089F5EB51
963FA1A6256E359D485107FD143B2BF21FDE9DA5744BC2615E86C31C89470CF0
D06C6397D9FCCB316EA9989430240759D2C4945D941F159FC02327F34B042BAB
B5C3A47C78E8C1A6FBCD396B1A51CC4B020B8AD401841EDABACECDB482D6EC5B
72D2BFEB4556720FADD49D07307C8B22ACB7E310CA4151A85C71EEF70E8D15DE
B3B00F26E0E166C14647A65ADA228A3D1C89025BE059306565DB1B1EFC37D358
8C1EB024254AFD049BA977BD4C2C605050E17940A89D0D4C5D963E792320F5DB
3706682E03D25D9E02487247819551465092CC22B6B56E93F3AB528038FEC3F0
668F866707A19B0463BE706EC729D2EE1653AAC7E29BD25BFB3241D4792F5152
ED415B4E7FA92C2EE5A22E27E8B75542C492E56D811C192E95542A6FE0BFE5A5
69273C2ABED4300D491B92D2AECDD278404CB84B1BB1BD7AFEC858215837D118
C0E928BE7E07CFEEB51A6D21375B772B8248C994564014015232A0DA4BEA1754
3274F407FED0837A236371F1A32056240F2015B1E7F4B2CA72C6B58610A66F13
407CFFBA5E0A2893C1F572D50F51286E9133B5A84239C9493B0574E77D281D01
11D00683354A000C9700EAFBC1FD104EA19DFCB87470190E7E2CE26E3A6FD0FF
2620B87B82AC8686B6206B530F17E9348BC7D04B948348802CE53A312443DB87
4DBBA5313A6A2A8DAB8A1CC9A594FF8C299281C0A261C8CB2226B732FBEEDE40
2C6ACC74A1A61379E2E1CD5548CD908268A32FA83D8504C442EA0E183ADBF7FF
9FD09C037AB03516ECCA93FF048235BD11A25DB07F164512A079C5392AC7F889
CE96AE5C8D9580BCAFCC087C35E76EED1A671E87C12E3045E15A687134736DF8
DA984772AFD189D68571A2ED7256F1E204230E41D3D9DD876F938951714A3973
0CA9310489F8E807C1C7A4E51AEA5BC030610A5D7263FF7E0F9FDE3E5E37A362
5B919000BD94D978583B942EB79CF2BEAC33FEBC9A67272EB10865BA8FB75FD7
9D280AB59F91B96C16C982DE848D76D8FA8620DFD7C80B7DEAE7264350D6FB3A
EF04794DA3305844A7CF718F6D1A4A3AFF6826173A076A1372ABFC54ED3AC6C2
09C9287FC830556CA694E21CA5342ECA7B10C90AFC4783D841D7B1E34FA3DB7A
2B706F3E21B0FBAB23E7257962FC3BC309CEA2C7239A9D6B44CC96825115ABD2
AF9A2566D2F3382C01569FBDB94C8D664A5DA0F7DC3DD140CA77C743D7BC1420
324ECF9E4780280EB119885E96A6C619CE3C0C8E1E264E2DEB137E5DC8149786
486D65667ECF47B1A1E20E9E6E4FC8323E0BC8E61BDD3BCDFC6575C69C03E31A
EFFC290472CBBD049DE3F840AEE37A2486034240F80E75D8A79E0762377DF660
52B12EAA16D678990B11A9BFBC03C1D4FCDA9FD4FFBB3E88352438102F10B7C5
9F04C013B6575B5E948FAB58EA691984A0E54E6B9F3F505FFFEF74D06FA1CDF3
4B8A95904C8A2763AA8AF5B71D00F5DE09DC1CDF87A08B6D181453063E14C12D
B7BB3775A6E2A901636273D9EEB833EA8CF20FD83AE899E28DADE10EEEC20BD7
BD93085A4B1AC80AC1AE8280C14767F1A487BD066007A0D050317BD081131A14
6EA0898ED59E46DA7B6254BDCCBC660686E2EDA0E77A705A653733BB5C5497D0
B130359F866CF293FB6EF0C2AC5BAA2DB0DED045E2DED3A2612D078333260359
16CF0CCB272D34767EA069E0F0B0D42327A18529D72E890EDA6195C2688438ED
E9ACDBEED41E81CA8EB5E43C2B09CE266EFCA03F2D7FF57F12B06F9E54FCC6A6
546676F6FFC5B8B7D3F0982B6FF0D21D949309F0C0B175CC1D0976F8C55C6AED
6E821C39041E22D91AB30922F2B2EC2746BC7DAB484991542FBC82D87B487507
559AB466F73EE23C2D3194DC5CE4C9AE66D3164613AC5CBB3DB501B64DA7C91B
C7ED2EE9027FC0906820B35D4F2CF66C4F9CE4A884B7C07155BCA884ECA5EB3A
ABB83F84DB1F5639599DC7D3F51241AB5D95C3BCB7AB1EC90B4BC989F74FB354
04B2D7366A34D335A47B8C00C05CB423482BF6C7970A95545424A08AFF9A035B
7F83F52B65A9799CE76E303B85664B624C65E9CA58184C7BE2BB9D9C86A4DE5A
8165EE3DA2E652B5022EE7893896BABD88931DE1D538F615787645DF5ACBBA0B
A8E5B899A37321AA7D4B283AC9234978C2DD81813A1EE5DB6EC170DAC1B6EF02
94892635B498765C07A38D2E9DB0B7581B11056C28278F89B0E60998379C07EB
C0EAEDC32AA69B8B836F92A61AFD35688315B2C3F860632FC13E4BDFB63214BC
41CC6859EAB3AC3034449213CAB99FA1D216563419CD6D6CE4E1B56F33E6C654
7AA9DCB5B05FC068DF02AC32408C8010AD004F6CCA9887830927F8CBCD49CDB5
18CAC1EAFF815FF2F6F527F936948201565003022C6C7390B4E3C2B219FB4F76
9F12BD25CA7B3B61D1A2F8DFEE795D04D5428B42FB66E0C254AF7B7A10CEF7FD
E5ADA5E217BE24851180E9A1700FBA66C7D2B0D7BFDE4F4EED1D24B821A40947
5620363657F6D048E651A689822CF815E72FC8AE9D835BE31D1DD8B54C9A717F
4DC319B4B59AE073936EA40B070524C7E71D5A7B64436DA107749746B516E29F
E3BBCB8F8C473E706670E11E5B221716F315FF097CD1841D0069FA69EA1898FF
9F9EC2518C77806A19730C97F54BEAD10B4729E5749A10EDBE644886443D1249
2C8517DF8D8AE98E2882439FA81903941B363A7D885F93C6DF9E1FD89F2F8CEE
B870C409ED13E78B4C914813B0A01DF8F876EDCC4F384055FD37C575726AD69F
F23D50EC5BEE2FB95A44F2B2E2DD94C933D90BED2C97B53738B4B2ED56EBE617
BEF17B9DF4F314A37F10FDE34C570D7BE76A496A58242F51E7321380CB042424
855F4B53071DF5A0DA5A31B8AAF9FB4F4C491625FF8FD008BD4402918043BEDF
77B840B2BE0DAAB4EF904FFEF935954AFB9BD2041241B1BC8519EB642C89E288
479664226DBB6F1171F9EEBC7E1273D0CABCF6B1BF7F26AF21C21D9B1B916F4F
603DDB68D3614B86566FC91D67AC3F4A4A96E256FA1A3BD35F4465AE4EC64D82
34BEB4BBDDCEEBD9A89D932E55F14CA2776F927C4FD3E0920790A57DAEA08C5B
169A3E2309DA6BA8684A5D1DEE81415796E13DCF906FCDADB092047831B16841
B250CD148557D72DD7E683BF122B38E2C4F614E59B395D1D9823D7D5F126D932
14B50A37FCA7120F8F3A8E42134F1B6B0C248D56F247AA68FB941839F600F61C
14247EFF780BBA3E5198D37CED44DEEC3455048FC451BCDB48DC414AE5293A60
5A59877D6DFD21EAD729CDB7B378CEDD34262B37A194EDD0BDB24AA42649375B
491DC08F6B03DFEB517B2FC125DA9373AFAA94F4E4BC09510A73E079F4ABDD8F
93529E898B13ABCDE7322323B3A2A02A0BF388E89B4F529A66FA22D38E3EE342
54475A1989BFB7A119CF95750D5A18BB4FA9CDA30DB6F1AEF8AE8448BBC999C9
FD0D74DE9A17A3153617F07CACE92977B68FB5A1CFB29FD42494D5D2B9C1ED81
2F3CCEEC1BC079E837DDBB57C7E351F9925FB96349F8D9786D8E6FF03E9C4C1E
67DB235577B68003BA14073E2702296B284F803259283005D97035874D2B9AFD
4D3F29B4B1E6EDE30DDB9C68348CC174A091791FA74520C8614D4FB1125CBD6F
B9367559D715ED057FDF6DAAC180C7FA5CCEFD0C5878A91B20D4919792C03CA9
3AFC986C34C08358A3E85F241E3F8F815FCE7C8E07C2A4258E17D65823264049
3803D47C96A2745580EDC957AC4291730A840A2BADA50A28342A2B7093A3F731
4F4F656E974389E133C53F89D5DD6407BB98B211697941A927BC72A0956FA78E
2DC624B2C253F76778698BD1510D509244AB0465D4261E3AC31D77C4F755096B
50C9CD8103CFF51490796CF35B02E38BFB36CBF2E6D0D7304344C4523C369946
C3BAD318835D4707E90A0340BB7B6ABEBE9EF7E7FF54D1784AB514FAC0FDC8DE
B8DE95405811AB2F25F2391855929C2C452295D698C749DF868A962183036CEE
800D650FE2CD2E74C038665ECA680B173A27305874D4AEC967043DBCF9275F02
7D92A0AC4C098A5DA5939BFA435FE56060110EA1E9FF2BCC9C5E93964FD43199
8133454CF0A83B9946D6D2235AE3F345BEFA7D935A4FD76D7A9CF080E34D1983
6FAB58E2C90382153341BC606532649904163DA1A7F009AEA3326E4E883510D0
DD754C5FD1B4ED4F1340B37A01BD97F34FD6BE3C7245A6DC39CBB817667EEDE9
B62D411DD89A32CB8A923E2342377642BCC3B805A60ED484FE92F0C684F4A041
9C055D1F1BDC06C89A7EF1AB04C8E0875032E159EE4FDC6240AFF044845F16B0
2CDF9CA3C2BDF4796BB6DBDB4AA40BFC0B4539E692126139F0AA26835DF10069
557053F660C1CA66B72BFC199714C3629599E8C4549EDA57B3D619B3678AFFD8
6AAD868BF8E257ED0CE37BEA35DB43628938193BAE9FC3BBEC27564A3E4D7B47
3606A827BE2D3F3CE879351061BA53184111DA5E9394DCEA8EA947CC9AC122D7
3CEF89E75217B016F0868103C1B2903D9758E6D0DA109C81F6F9B8676E1D32C3
55DA8AF33E9B551825C8FFB6230D3123380AAD4A28A4BC9228A30349FD05C581
C9C1D23DFC756562FB568CFE3D6FFB5B684693426B83175316E6E267671EAAC6
9669F2CC91A2C8B36945A89FA01F76BC7F7708D9DCA34F5838C65FDF14405AD0
EF2B7EC4C08E39463CB0127886FFEC971AB6AB1CDB17394588881EF3502D2272
FB1D5EA8B1E1C2D6AB9227F4152F7C46E8EDC339AE0FB8D0F13441F58C588919
BBA377177966F934768FCD1C886ACB3D1022F7FBF7D0141D40094862CB2ACA13
7E7A98AD8FD211B579E0B60F46E593C13C05D89C0D0A49DFC375BA2D437024D3
9DCB0C1CD99B250948651F916D7BBFCF279CC9FCCF79F2631BD3D20775C5BE29
109FF2B931673B3FFABDD21701509F47BE51EC1AF345F3E2EEA6FEC3A104C7D9
11BB3AD46B2A36DE2F8BF821A739FAB9368142FCB346682F40A82CECF627F2BE
2AC15E661EA9CB008CA30E8977819CDD7BBF0B9B0C777ACD0210BD2400E8F70E
D6395B6ABD1E8C4E17D98265BF0E0150053C6993773F02B5D41FBDED8FEB58A0
6037A79C3424E56BEBF481AB03494BF75E70DD28D091234019D2E22487C4EA20
91F8E6E8FEB1113E9693CAD437AB221B1C0DE273405172320E8C07D88A6B89D3
6D0DCAEDE1C7C826056677D71FBF9138A9129E282E22B78C22CA36234A71023C
0206F4D481A294B8874E0707E3403594CE686578051B8F21EA398E2A6345FFDF
17AB371E6EC3982129B55A27E737D99A38875F5558146EA08DA0C6D248D774FF
97B101950715B552B759240353279EEA6062F53B93E6645939A0A69BE82F08CB
530D92854140358AE4E7AEB453CDF4F95D7CC6BB9A84799126F7B981B04A45EB
001FA13E44683D3679E52237D62D238B6238F7F06EA6D9472801EC00754B2523
E1F4D31AFB1D9675E87B3425FAA0924B45CE80295A6BAE37B92ECB4634452371
4CE9C02A06D93CA8594725A4278129BA17158F1DEEFC669CE6172EF070500A18
CDDEACAAFAE5D4964C3D95D4AFB5224770D8DDD641D72BA63E738ECA67BA3D06
ACF00B542E270551E4704031751C9283B62DCCC0A092903F20572AAAB15FEF7E
93C4FF7BCFF11DEEB15DD6A11105950AA5B7F2B019500E8FB7E600C3FFEC66FA
0B727FC6AE9881424213CAD572FDBAD9168E9DC91AC4528AF6B5E307AA819A28
1C4FFE76273D0A94C849532EC1C5E19479828C72BC5CB72B6DE6BE1AFC4028F5
71EC315B08BCD6CF66E574064EA0A89FFFF693F91A0F1236BE40290FA865656B
49A2E46D881F77D54798FF0F3074A82D3474850D054DBD9ED913764CF4686BFB
D66879769650099A6CF35C3636F992AF3B6CD034C264D1E1C18DEC47C52E9693
7FEABC9828988357740B80BB8B3C209E1A0EC273F4F8CB2278D72A58A40EBB94
A5BEA997722DFA6BDA7AAA432B33329F0F1BC21E76BDB71843002A6D330C47A3
E369C75DCED29E537F07F65F9082E51161F67FF7B142E8036172F9314D07150C
7E0756307C3606A752F86D5A8B2FFEBEE83ACCBC73C481DCC0A6D3663AFF2DE3
6A2249BFD2DF460161D3EA5C11AC29B6D09B560FF43A19CAB380E2ACA02B1F4D
E65757EBCF9374A4F388507EB1C5911495DC5E665EDC0E38B6E9E00B01FAD770
5D8DC604634225C5915DEF9FD4C7309C37D13848552D03C07E06969315884369
EB91CDBA8A977F82C51263082991C3C58874284F7220ED41C1D94434B7ACFF3C
578C639C650E269827509C6B6786CA1C943175E18531FB28DACBFE60AB88B310
15807FB810E0B8ACF11A7F61026CE0F20161A57C927D174FCED4378A4107E7FB
C206CB04E1C53C079B8BEAA3606AE9FFEA566D0E6EF73CB3681E2EFD55C474A3
7022FA7421D754E2DB21C08934B4A5E4392D251E251C9CF287346DBEAE13E3C9
6C60A9F95F0CAE521686BAA8BA59A971ED0E158D7EE0F6E0F6716830A1C99245
D2AE695508DEE3DC44FD280DF9075DD5C098790639F8D7ADA62D79BC3B714EB3
041F78D3D8B547009BD4A77CA17BFB92A97BEE9D63DE0C1F39290B80B1AB643B
BB56BF05CEA7C520ACDF654AF4A9B5914B2E12763C99DFDA2AD06079E6A85B08
5E3FC159A764CBDFACB751AEA306E338D53337FA4B6871328DA06816F25B2D5D
9BFCF9B86BE6301AF99D10B74C7923C813CFD5891DA5F62D024A40E95DA4777C
4E8C26BEE936EC149E8E52D7250B1BCB187CF6C726CCA5991315FCD2BD243F79
9BFB7C87CEA99EDB045DD10F23FEB32A2191D2EA2BF7995852A52C01AB47D189
74E021F96A8E2689C751FF476FD3B7CF03139D80FEAFEEA8DD65497B2C0951FC
283FBA198DF4AD7403AAB0923139F5BB9BA8EE6FF1524430AE8D6F4D2EB5B770
817E6A811BD786D162EECE1299D2E0B6B4D08ABF78972EE96EE673E050FBBEE9
8FA72FF4AA3A4AFF1E4AECC67F0E2C27CE0D5E9593FB6F1BFCB94126AE87FFF8
341D80585E0F711ADE26B55D7E0A6962A5BB20CFF702E82E0B83DDC0894853E3
B24FF8E2E21B4214BFC6B3B57876DC7B49928DC3511C81BB00166D1ED15D14ED
B4B7F72DE42A9AEDEAD461E11258B1391B26D0ACEBB7C4599E08734C7584FF7B
AAD152941E94D87E9EE95E4E22C9A049DCA9F14AD4DA638DA9ACA8B0E67A58D3
39FBAF4C92C6919EE844A58B24B25C2C68C72337319AF6493D9CC8AEB07A8605
9F00A507A6010E2895636F4F20B1B7FC5AD2133177B75E8CBC5317912DB1CC8E
D7EC3BFC952C6635F34E0F5A3459D539D14C9418DDA6D72571FD0430EC03692D
0FEBA83EA25393542577D7B824A3231A26E8032875F8C8686C5F1C69F1B88FF9
FAB9EEC74CE1207781A91633531E8038D740E5E1618E12B47C135ED38A599224
6FF2A926C8B49056309B0A84346782A0288045F82E369BCD5731A28930BE73A5
35DF55C5758C3945E1EDB8DBB6BC87A04D0FAEA66602D14EBE62496B367F6B6F
AD9E6554C31793E525FE9773CD6261840BE30D5ED95A7988F0E208EE56B2F335
F5069D84D4FF9A05BA0E0DF56E098FA41E98F68AF93CA4D44AD1E2AA7991A45F
647FD8A34FEF5E5C1BDCBD480F45D6C7A2152A92920A4451A4F2335C817F8DBD
0A099C920A66BA0C8CD3B680702971E626328A95D35E831F6D4CC39AB89D0B22
83B86618F816C700A346BA6B65B2728F2FA33E6FA82436A3D49E22FD448DF785
1992FF6C94365A0A6198885F926B414A08AA1823E44ADB12B559760BCC262816
A5C0627D60AD0AD4C99C302783F4B3BB370271D507016F6EED486064A9901418
EDC58FA04C4D3BF0104D0EE3BF2E2AB61917E254A78A598DBC0B9A1993A9B392
1AB23B1661565CCD176FC4207617881E56C0F49F2CDF9112EA8C16F96204CF7A
6B950C4DB0EA790B3F8F02F97A403F68CD5C8DE698C04608CA3A2958751466CA
FF8ED02E44D42D565CC8F09F28ECD1BCE5783813F988484C097E367DCE5D1B73
29C34BA356358F3BBC7E2C198443BF9E815902F0255A8FF05B51BC2692F70A26
A546D0223E29DEBFC9FB24BAEAABDF1865DF65D6F776A9D16BFAC56625002EB5
268BE5BB7602483A34BCDB7A6AF688C07EC1BDCBF2AD010774ACB350C08D4954
EB56679242841EE020D967B19524BE80563249AD06A3DA2E7718E688065F1197
8327ACECD2C2BCAA14DB3B19A0C626D4235A16103B233C198DB21746414A9F32
EA52738D88710064120B35D28484C9C310644F6E9537AAB23CEBA90F205384E9
E316DE44C79C0CBF2ECC7F87F3765B19C5314DECA79ACAB20688C06114C8BB8D
B694E2B2C76CAFE8C971E198D2082368CAF24F186EB48F51E3E8376F1796C9C1
D9E888C2671C380ECE78CEBF23E63D77C2E10F2F935229A4F14FEE5BB03BE99D
206E5FC13FFC0CAA5D90931E47FF34812A297CD05FEB8B99ABB4A2BCB15BD983
F43F7731184DCAE00F427536355822629C50660045210FB37711C0E606B161DA
D53941D780067DC61C85540BFBA4CB96725740DC99F4D5A6A408707817F6627A
2BDE4801FD63D06720DE05A24D72F1AE471D4FAA644DD051F49D718EE5A3ACC4
38695EC57CC310C318B868DF27D18975DB8A54F2EEC08261576116857BEE0AAB
D1596F318874ABECADFEB6054E5083FF494BC2F3EE7C2D57A5A5F993B4BE4110
4A1659CB1E13A20943AD8084A6EB553D7902254C07209F57608AFEB1F89AE665
C30CAA70F546A4AEB9BB535172D5918BADA04DB48C41AE95EFAAAFB3A0DEADD4
F4FCECF796137A0C192B3083C310783D6C600B6781760B87990F072A5D2BFBD4
E62BE5DD0AC67C89928CA64CA2B9CFDC1D382B197321EB072D0A303B9AC4F4BD
1A12EE868CEEEAAA02DD904DD0159137DF6F5E99CE3EC8E2D3C3B645C739B423
0CCDD36547D58E055EDD44B0527B8C10B3C74B3BF3FE2D2AA6822B5F014547CB
BA09D376016593761B1167D7B5CDB142BFFF7724724CE1891721B24D99E0CF3F
6E9040D94C8AA55B619738429BC90AF9755B15D36B3AC0B08982A3E7421DFBED
35A4DBD469786D1A37F5112A3F0B34B87B78218EDF4D4D39F6835A11F8F30088
DE87B0194C4EB09FB386EE637D6E9FF2A09A02FB39AB4A468B4528A623C9B5F3
A7E4307CEF4B61F82C58BC19539479CD2A277CC4A1ACC39516B98373FF6B3685
5FB44471A97C26D4149311F4EE4F0D2FDDDAA3E6536762E343DDF81F6D094320
9364D8A27309E060438D05DCAABB46F63E7954773521B3453E7A5294CBCE9D35
8402A4AC8D8723413FC94E2C21FAE5E22C00F9070FBF0F76767BE28BF972C370
5658CC2DA59EAF43E5C40CD2A6D1A85E6A816D0197617A75BA8F537900B837ED
0DB30F5967471AAAA7F7D29B2C3448FFC80E1192A561C19BE8ABB95BC0A4126F
B1F7C4AFBA9934F4D677BDE57E329DA709ED8FCCC44EB230D8F7760AC5CF7C1A
18FB1775598D52A3EBD1B3A938C1FD8432DEAB8C44947343208DAD93EABBE583
26D37BA058FCCEE80618930B1C274446CB294351C44063381707348BD0A3DD10
12027B6BC7A87E0A6A3EC1E26BD9639C4855CD983A1A8F8F62E871C9F130406D
3F679217EAA2A9D405AA0313B045CAE7AF9FD2B313BB50E0246FE12B18D525E3
398FDF4ADF159C96EC104B95DD726CF486F6C36010FC1D596DC7D049036301E7
10FA0ADCF9B1EEAD91FA508859A748D13FAFAE46F541147790DDC7086322EE36
6FE00E26EB7233A0EDB15BFA95FB856FFA0565181A28E8ACCF05F066C3FC1A02
D901E1B80A4DF55F1F11C022477768688C6DF8237575479A732AB0682E0EF94B
6F2C48898A52D8BC8928FAB57555B401D305A339B0CE2CB7E119D5671E599C0C
06D48209200725B331DE1F86626F361A439A994BEB2B3C1C07AF98E7FA151E54
7C44FCE3D9930A865825E2A4A93F3A4E78987E8B640659E666CF4199C291A3F1
3117432C6667269F550C8A03876588D352DB1760678B3A1AA14DD75CE5086BF6
8AA081858F58F67862D66D82CB8A9983ED3D8A1564050FDB6618E219B3AC4AA5
DCB5A4161C60F9281904DEC18AAF028CCF9454CB3F248C1B5236769463CBE052
BC0DC79968034EA5B834A94225806D7D2C2FB2A0307449A838E372B52F25A370
0AB6C72744887F278DBD9C753E87654864932A6F1B937B06798B6D1A70EEBED3
DB8552ADC6ACC11AFE1BF6226803E5DAEBA4868C3DE791BE69FCD062E3D513D6
547C0833F595DC8CFCD16E6623DEAC83711B84C5BB7E02368E01828F730150FF
6C85093F1EFF8A4B52DEF2C169AAC99A32BE71AA764301C39CAE85443519DC2A
66F04CE218B770AC0E6B0C43E838653F9AF13AABA178702F7CED0325CA9E305E
69A46BF5F7E0F210C7521A14EC6EB5A51E10221B4EF82D870D2FF9F3FE78ED51
784E5FCA2A3C1646D80B817D40F0707B2DBE42CEECC3FAFCBC6C7BBB8185C79C
6A41F6B924998E5F948FBF7CC753B80F8636FD1EEDCF6F6871B933C495A10B69
F1EBD75097DB9486055FB7F9838DF0E4325064995A5B34A39426C9FBF4323A90
102BD9083F134BE07796621D95256E0AD2C04A7E65552C60C0747DE077207D7F
350D3148FB38E4DAF40C0691CF8BBDBCF99FD40E4758EFBD912550B66737FB9C
08C4A40C26928DC690F55BF058169BD6A42E7560407B24DE4149A41941A0BDB4
5D751F66ED5F806C1901F2976A0CBC9AE1CDE870B78085DEB498856FC594778F
268C130DBE63643BA4C7EF0B920E246F3AA5990ED7B6F7D4D301C0D2C1434C52
EC34D88B690439A3A687066DB874B38CABD074D32D21303474713D0672D503ED
19052CCA0505507BAD73CA7DAF15037FB67894AF25BEAB24FB0E9D91D2C1CBB4
CB5790DBCCD67F292528BA6A53026820C95537494B990DB99615D13690EDCC05
B2D65FC2D5B82F7384063E9A2B099D2501FE2E0CA4CDC2F7EBF6DE65823FAF79
654DD49C7042F14D9C03BAF976CD3D2332A3ABF4A3AC23049BC4F2A01247F84F
4D320A12DDF93D7C277CBE5C42168D5118612C2A599427F2A40D2AE6B71E93AF
9EDEE9AE87D251F008B54272364CF083E7DD8275CF1A845CABD04F4EBD12BDC1
56CBBA2D8FD2D22B34A752E8881E3DA8E7B0AD88F35AD5127ECB9F286B526F51
8231408E02F5A34FE1C5EBF6607A8A8F953C2659848768EADA8BB31EC7BF4D38
AFF13919FF8EDB416CE5F1FBF59C16BD1E45D782860B18B71A4B2A78883966E4
9CD6FA928FD2D6A42793BE32474509A3AEA036EE4BA11595941B322A0FF96FD1
68707E7AB6BD84814C4C4777A00A6C99127C682F5F7607EF235E781C3FCD9AAE
05A43E4358AF6C9142EC699C49E69C8E2455430DFB2A37BF4CB331EBD5471DE2
74B748F90996FB598040A2C270FB3BAB2DEAF0E763BF8B17450A8FEF35010195
534A887BE379DC8000A6FCF23B5D26265730A84BB28B144C7C4C5A1C996A1AB1
5024AD4A806304BF07C4AC10EC7ED2CC88241B62B1EA97331BF0DE4B76B2D2EF
C472E284C2EC5AF3CC7BF30401C14459B25C722D957D38D08ED8180C4C92077D
E392EA9F5582EDDAF9E0459A364420A56322C1BD49D632A264147987AD15CB2D
918E3DBD0C8B8989F0B6A6C8659ECE0C83A13A657011EE64BB785632E7F4A5E2
59143889401807299C34E246D456DFC33416C08FDE6EB876890DDE7900E11A87
91DA4FB0E7E0AE96BD226B67F561A11AF296797850C3BCAB8DB74AF371A19FCB
EEB70AB58554BAE5811627217E2B34362AEA903B853B451E5B4107563E367D5D
D0E0561579E9C7F0FD13BBFCF23842A43DB29E55F8673B06E2EAEE0B05705FC8
F3AF9E59A8EF097F651A964D8764D93FE6C44B2DA8066B03D708BFE1B86C12B6
0F696EFB18DB46DA3DA9F45FC7398E8E5CB87EDEF6DE045BB5FC0895BE10D917
5FED7341CA227977FCB3AF89BF07ED835768873E5377C82C08CED9C55E9C1679
402F15786AEDADE2833BA0B2B4018C8D4DE496A3770279D0D01FFE267BBBBA32
F504030716D9C4C84FBE07D282FB7A7F4DC83C0927B5B368CAC6FCDC6BE193A1
C475BE97BF8E0EA77347BC63C4ADD5DB4398D9A571A76657BBF5AD38C7C4607D
1EBBD929A93BA549BBBDD6C4EA92E6AC50F5F1916A93F74095C420B5C94F0D9D
E74C5DE4F5AF50D6D381D40024C19980FB2E7DEBF94AF25FC6D0A74CB61845BF
DD136DE0ECA1DFC653C3ED6F6E649F1011F4A25902F5AD3ED02EE44105076AFE
C063ED5916565A5E4D4A023703BE0D3DD8E419E4514BFEEE6258D6C8B0DF997A
23995A471A33A7BBAACEF2A439B496111486D2ADFC2A189992F6A20E79618D4D
C8B577F64A2CD700F671404779B6D0E0C1057839131A0B0C57D19FE50FA337BA
F7F4CC3B65FD3D4AE127154B1DE64E7A534C315A69EE8CDBC9D7
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
cleartomark
{restore}if
%%EndFont 
TeXDict begin 40258437 52099154 1000 600 600 (foo.dvi)
@start /Fa 220[50 50 34[{}2 99.6264 /CMSY10 rf /Fb 134[44
3[46 32 33 33 1[46 42 46 69 23 44 1[23 46 42 1[37 46
37 1[42 9[85 3[46 4[62 1[52 7[63 68[{}23 83.022 /CMR10
rf end
%%EndProlog
%%BeginSetup
%%Feature: *Resolution 600dpi
TeXDict begin
 end
%%EndSetup
TeXDict begin 1 0 bop 0 2135 a
tx@Dict begin  gsave STV CP T /ps@rot 0 def grestore  end
 0 2135 a 0 2135 a
tx@Dict begin  gsave STV CP T /ps@refangle 0.  def grestore  end
 0 2135
a 0 TeXcolorgray 0 2135 a
tx@Dict begin  gsave STV CP T /ps@rot 0 def grestore  end
 0 2135 a 0 2135 a
tx@Dict begin gsave CM STV CP newpath moveto 3.0 neg 0 rmoveto clip
setmatrix end
 0 2135 a
0 2203 3298 2204 v 3298 2135 a
currentpoint grestore moveto
 3298 2135 a 0 101 a
tx@Dict begin tx@NodeDict begin {12.18193 5.2375 80.26413 40.13206
3.01385 } false /N@M-1-1-1 16 {InitRnode } /NodeScale {} def NewNode
end  end
 0
101 a 120 101 a
tx@Dict begin tx@NodeDict begin {} false /N@WS 14 {/X 25.6945 def /Y
3.47221 def /w 40.13206 def /h 8.70972 def /NodePos { OvalNodePos }
def} /NodeScale {} def NewNode end  end
 120 101 a @beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { BeginArrow
2.  2.  scale  false 0.4 1.4 1.5 2.   1. .setopacityalpha  Arrow  EndArrow
 } def  0.8 SLW 0  setgray  0 360 40.13206 CLW 2 div sub 8.70972 CLW
2 div sub 25.6945 3.47221  0 Ellipse closepath  gsave 0.8 SLW 0  setgray
 1. .setopacityalpha   1  setlinejoin 0  setlinecap stroke  grestore
end
 
@endspecial
Fb(W)-7 b(alk)27 b(South)2600 101 y
tx@Dict begin tx@NodeDict begin {12.18193 5.2375 80.69617 40.34808
3.01385 } false /N@M-1-1-3 16 {InitRnode } /NodeScale {} def NewNode
end  end
 2600 101 a 2720 101
a
tx@Dict begin tx@NodeDict begin {} false /N@WN 14 {/X 25.84727 def
/Y 3.47221 def /w 40.34808 def /h 8.70972 def /NodePos { OvalNodePos
} def} /NodeScale {} def NewNode end  end
 2720 101 a @beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { BeginArrow
2.  2.  scale  false 0.4 1.4 1.5 2.   1. .setopacityalpha  Arrow  EndArrow
 } def  0.8 SLW 0  setgray  0 360 40.34808 CLW 2 div sub 8.70972 CLW
2 div sub 25.84727 3.47221  0 Ellipse closepath  gsave 0.8 SLW 0  setgray
 1. .setopacityalpha   1  setlinejoin 0  setlinecap stroke  grestore
end
 
@endspecial Fb(W)-7
b(alk)28 b(North)1541 446 y
tx@Dict begin tx@NodeDict begin {6.83331 0.0 22.25006 11.12503 3.01385
} false /N@M-1-2-2 16 {InitRnode } /NodeScale {} def NewNode end  end
 1541 446 a 1541 446 a
tx@Dict begin tx@NodeDict begin {6.83331 0.0 22.25006 11.12503 3.41666
} false /N@Start 16 {InitRnode } /NodeScale {} def NewNode end  end
 1541
446 a Fb(Start)1395 795 y
tx@Dict begin tx@NodeDict begin {12.58444 7.58444 57.28659 28.6433
3.01385 } false /N@M-1-3-2 16 {InitRnode } /NodeScale {} def NewNode
end  end
 1395 795 a 1487 795 a
tx@Dict begin tx@NodeDict begin {} false /N@S 14 {/X 17.5695 def /Y
2.5 def /w 28.6433 def /h 10.08444 def /NodePos { OvalNodePos } def}
/NodeScale {} def NewNode end  end
 1487
795 a @beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { BeginArrow
2.  2.  scale  false 0.4 1.4 1.5 2.   1. .setopacityalpha  Arrow  EndArrow
 } def  0.8 SLW 0  setgray  0 360 28.6433 CLW 2 div sub 10.08444 CLW
2 div sub 17.5695 2.5  0 Ellipse closepath  gsave 0.8 SLW 0  setgray
 1. .setopacityalpha   1  setlinejoin 0  setlinecap stroke  grestore
end
 
@endspecial Fb(Lo)r(oking)333
1131 y
tx@Dict begin tx@NodeDict begin {0.0 0.0 0.0 0.0 3.01385 } false /N@M-1-4-1
16 {InitRnode } /NodeScale {} def NewNode end  end
 333 1131 a 1375 1480 a
tx@Dict begin tx@NodeDict begin {12.58444 7.58444 62.19635 31.09818
3.01385 } false /N@M-1-5-2 16 {InitRnode } /NodeScale {} def NewNode
end  end
 1375 1480 a 1473 1480 a
tx@Dict begin tx@NodeDict begin {} false /N@Sh 14 {/X 19.30562 def
/Y 2.5 def /w 31.09818 def /h 10.08444 def /NodePos { OvalNodePos }
def} /NodeScale {} def NewNode end  end

1473 1480 a @beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { BeginArrow
2.  2.  scale  false 0.4 1.4 1.5 2.   1. .setopacityalpha  Arrow  EndArrow
 } def  0.8 SLW 0  setgray  0 360 31.09818 CLW 2 div sub 10.08444 CLW
2 div sub 19.30562 2.5  0 Ellipse closepath  gsave 0.8 SLW 0  setgray
 1. .setopacityalpha   1  setlinejoin 0  setlinecap stroke  grestore
end
 
@endspecial Fb(Sho)r(oting)333
1816 y
tx@Dict begin tx@NodeDict begin {0.0 0.0 0.0 0.0 3.01385 } false /N@M-1-6-1
16 {InitRnode } /NodeScale {} def NewNode end  end
 333 1816 a 214 2160 a
tx@Dict begin tx@NodeDict begin {12.0478 5.2145 28.61365 14.30682 3.01385
} false /N@M-1-7-1 16 {InitRnode } /NodeScale {} def NewNode end  end
 214 2160 a 271 2160 a
tx@Dict begin tx@NodeDict begin {} false /N@D 14 {/X 7.43056 def /Y
3.41666 def /w 14.30682 def /h 8.63115 def /NodePos { OvalNodePos }
def} /NodeScale {} def NewNode end  end
 271
2160 a @beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { BeginArrow
2.  2.  scale  false 0.4 1.4 1.5 2.   1. .setopacityalpha  Arrow  EndArrow
 } def  0.8 SLW 0  setgray  0 360 14.30682 CLW 2 div sub 8.63115 CLW
2 div sub 7.43056 3.41666  0 Ellipse closepath  gsave 0.8 SLW 0  setgray
 1. .setopacityalpha   1  setlinejoin 0  setlinecap stroke  grestore
end
 
@endspecial Fb(Die)452
2160 y
tx@Dict begin gsave STV newpath /ArrowA { moveto } def /ArrowB { BeginArrow
2.  2.  scale  false 0.4 1.4 1.5 2.   1. .setopacityalpha  Arrow  EndArrow
 } def  0.8 SLW 0  setgray  /ArrowA { moveto } def /ArrowB { BeginArrow
2.  2.  scale  false 0.4 1.4 1.5 2.   1. .setopacityalpha  Arrow  EndArrow
 } def  /NCLW CLW def tx@NodeDict begin 0.0 0.0 neg 0.0 0.0 0 0 /N@Start
/N@S InitNC { NCLine  } if end  gsave 0.8 SLW 0  setgray  1. .setopacityalpha
  1  setlinejoin 0  setlinecap stroke  grestore  grestore end
 452 2160 a 452 2160 a
tx@Dict begin gsave STV newpath /ArrowA { moveto } def /ArrowB { BeginArrow
2.  2.  scale  false 0.4 1.4 1.5 2.   1. .setopacityalpha  Arrow  EndArrow
 } def  0.8 SLW 0  setgray  /ArrowA { moveto } def /ArrowB { BeginArrow
2.  2.  scale  false 0.4 1.4 1.5 2.   1. .setopacityalpha  Arrow  EndArrow
 } def  /NCLW CLW def tx@NodeDict begin 0.0 0.0 neg 0.0 0.0 0 0 /N@S
/N@WN InitNC { /AngleA 0.  def /AngleB -135.  def 0.67  0.67  NCCurve
 } if end  gsave 0.8 SLW 0  setgray  1. .setopacityalpha   1  setlinejoin
0  setlinecap stroke  grestore  grestore end
 452 2160 a 452 2160 a
tx@Dict begin  tx@NodeDict begin /t .5 def LPut end PutBegin  end
 452
2160 a 366 2185 a @beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { BeginArrow
2.  2.  scale  false 0.4 1.4 1.5 2.   1. .setopacityalpha  Arrow  EndArrow
 } def  0.0 SLW 1  setgray  0. true 3.0 neg 8.7333 neg 23.63326 14.73332
.5 Frame  gsave 1  setgray  1. .setopacityalpha  fill  grestore end
 
@endspecial
61 w Fa(")p 366 2091 172 4 v 366 2231 4 142 v 534 2231
V 366 2233 172 4 v 452 2160 a
tx@Dict begin PutEnd  end
 452 2160 a 452 2160 a
tx@Dict begin gsave STV newpath /ArrowA { moveto } def /ArrowB { BeginArrow
2.  2.  scale  false 0.4 1.4 1.5 2.   1. .setopacityalpha  Arrow  EndArrow
 } def  0.8 SLW 0  setgray  /ArrowA { moveto } def /ArrowB { BeginArrow
2.  2.  scale  false 0.4 1.4 1.5 2.   1. .setopacityalpha  Arrow  EndArrow
 } def  /NCLW CLW def tx@NodeDict begin 0.0 0.0 neg 0.0 0.0 0 0 /N@S
/N@WS InitNC { /AngleA 180.  def /AngleB -45.  def 0.67  0.67  NCCurve
 } if end  gsave 0.8 SLW 0  setgray  1. .setopacityalpha   1  setlinejoin
0  setlinecap stroke  grestore  grestore end
 452
2160 a 452 2160 a
tx@Dict begin  tx@NodeDict begin /t .5 def LPut end PutBegin  end
 452 2160 a 366 2185 a @beginspecial
@setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { BeginArrow
2.  2.  scale  false 0.4 1.4 1.5 2.   1. .setopacityalpha  Arrow  EndArrow
 } def  0.0 SLW 1  setgray  0. true 3.0 neg 8.7333 neg 23.63326 14.73332
.5 Frame  gsave 1  setgray  1. .setopacityalpha  fill  grestore end
 
@endspecial 61 w Fa(#)p 366 2091 172 4 v
366 2231 4 142 v 534 2231 V 366 2233 172 4 v 452 2160
a
tx@Dict begin PutEnd  end
 452 2160 a 452 2160 a
tx@Dict begin gsave STV newpath /ArrowA { moveto } def /ArrowB { BeginArrow
2.  2.  scale  false 0.4 1.4 1.5 2.   1. .setopacityalpha  Arrow  EndArrow
 } def  0.8 SLW 0  setgray  /ArrowA { moveto } def /ArrowB { BeginArrow
2.  2.  scale  false 0.4 1.4 1.5 2.   1. .setopacityalpha  Arrow  EndArrow
 } def  /NCLW CLW def tx@NodeDict begin 0.0 0.0 neg 0.0 0.0 0 0 /N@S
/N@Sh InitNC { /AngleA -145.  def /AngleB 145.  def 0.67  0.67  NCCurve
 } if end  gsave 0.8 SLW 0  setgray  1. .setopacityalpha   1  setlinejoin
0  setlinecap stroke  grestore  grestore end
 452 2160 a 452 2160 a
tx@Dict begin  tx@NodeDict begin /t .5 def LPut end PutBegin  end
 452 2160
a 327 2170 a @beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { BeginArrow
2.  2.  scale  false 0.4 1.4 1.5 2.   1. .setopacityalpha  Arrow  EndArrow
 } def  0.0 SLW 1  setgray  0. true 3.0 neg 8.34444 neg 33.1889 10.70554
.5 Frame  gsave 1  setgray  1. .setopacityalpha  fill  grestore end
 
@endspecial 28
w Fb(space)p 327 2109 251 4 v 327 2213 4 106 v 574 2213
V 327 2215 251 4 v 452 2160 a
tx@Dict begin PutEnd  end
 452 2160 a 452 2160 a
tx@Dict begin gsave STV newpath /ArrowA { moveto } def /ArrowB { BeginArrow
2.  2.  scale  false 0.4 1.4 1.5 2.   1. .setopacityalpha  Arrow  EndArrow
 } def  0.8 SLW 0  setgray  /ArrowA { moveto } def /ArrowB { BeginArrow
2.  2.  scale  false 0.4 1.4 1.5 2.   1. .setopacityalpha  Arrow  EndArrow
 } def  /NCLW CLW def tx@NodeDict begin 0.0 0.0 neg 0.0 0.0 0 0 /N@Sh
/N@S InitNC { /AngleA 35.  def /AngleB -35.  def 0.67  0.67  NCCurve
 } if end  gsave 0.8 SLW 0  setgray  1. .setopacityalpha   1  setlinejoin
0  setlinecap stroke  grestore  grestore end
 452
2160 a 452 2160 a
tx@Dict begin  tx@NodeDict begin /t .5 def LPut end PutBegin  end
 452 2160 a 255 2189 a @beginspecial
@setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { BeginArrow
2.  2.  scale  false 0.4 1.4 1.5 2.   1. .setopacityalpha  Arrow  EndArrow
 } def  0.0 SLW 1  setgray  0. true 3.0 neg 6.4 neg 50.35564 13.34444
.5 Frame  gsave 1  setgray  1. .setopacityalpha  fill  grestore end
 
@endspecial 29 w Fb(anim)f(end)p 255 2106
394 4 v 255 2216 4 111 v 645 2216 V 255 2218 394 4 v
452 2160 a
tx@Dict begin PutEnd  end
 452 2160 a 452 2160 a
tx@Dict begin gsave STV newpath /ArrowA { moveto } def /ArrowB { BeginArrow
2.  2.  scale  false 0.4 1.4 1.5 2.   1. .setopacityalpha  Arrow  EndArrow
 } def  0.8 SLW 0  setgray  /ArrowA { moveto } def /ArrowB { BeginArrow
2.  2.  scale  false 0.4 1.4 1.5 2.   1. .setopacityalpha  Arrow  EndArrow
 } def  /NCLW CLW def tx@NodeDict begin 0.0 0.0 neg 0.0 0.0 0 0 /N@WN
/N@S InitNC { /AngleA 195.  def /AngleB 45.  def 0.67  0.67  NCCurve
 } if end  gsave 0.8 SLW 0  setgray  1. .setopacityalpha   1  setlinejoin
0  setlinecap stroke  grestore  grestore end
 452 2160 a 452 2160
a
tx@Dict begin  tx@NodeDict begin /t .5 def LPut end PutBegin  end
 452 2160 a 305 2181 a @beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { BeginArrow
2.  2.  scale  false 0.4 1.4 1.5 2.   1. .setopacityalpha  Arrow  EndArrow
 } def  0.0 SLW 1  setgray  0. true 3.0 neg 8.34444 neg 38.41116 13.34444
.5 Frame  gsave 1  setgray  1. .setopacityalpha  fill  grestore end
 
@endspecial
28 w Fb(no)h(k)n(ey)p 305 2098 294 4 v 305 2224 4 127
v 596 2224 V 305 2226 294 4 v 452 2160 a
tx@Dict begin PutEnd  end
 452 2160 a 452
2160 a
tx@Dict begin gsave STV newpath /ArrowA { moveto } def /ArrowB { BeginArrow
2.  2.  scale  false 0.4 1.4 1.5 2.   1. .setopacityalpha  Arrow  EndArrow
 } def  0.8 SLW 0  setgray  /ArrowA { moveto } def /ArrowB { BeginArrow
2.  2.  scale  false 0.4 1.4 1.5 2.   1. .setopacityalpha  Arrow  EndArrow
 } def  /NCLW CLW def tx@NodeDict begin 0.0 0.0 neg 0.0 0.0 0 0 /N@WS
/N@S InitNC { /AngleA -15.  def /AngleB 135.  def 0.67  0.67  NCCurve
 } if end  gsave 0.8 SLW 0  setgray  1. .setopacityalpha   1  setlinejoin
0  setlinecap stroke  grestore  grestore end
 452 2160 a 452 2160 a
tx@Dict begin  tx@NodeDict begin /t .5 def LPut end PutBegin  end
 452 2160 a 305 2181 a @beginspecial
@setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { BeginArrow
2.  2.  scale  false 0.4 1.4 1.5 2.   1. .setopacityalpha  Arrow  EndArrow
 } def  0.0 SLW 1  setgray  0. true 3.0 neg 8.34444 neg 38.41116 13.34444
.5 Frame  gsave 1  setgray  1. .setopacityalpha  fill  grestore end
 
@endspecial 28 w Fb(no)g(k)n(ey)p 305 2098
294 4 v 305 2224 4 127 v 596 2224 V 305 2226 294 4 v
452 2160 a
tx@Dict begin PutEnd  end
 452 2160 a 452 2160 a
tx@Dict begin gsave STV newpath /ArrowA { moveto } def /ArrowB { BeginArrow
2.  2.  scale  false 0.4 1.4 1.5 2.   1. .setopacityalpha  Arrow  EndArrow
 } def  0.8 SLW 0  setgray  /ArrowA { moveto } def /ArrowB { BeginArrow
2.  2.  scale  false 0.4 1.4 1.5 2.   1. .setopacityalpha  Arrow  EndArrow
 } def  /NCLW CLW def tx@NodeDict begin 0.0 0.0 neg 0.0 0.0 0 0 /N@WS
/N@D InitNC { /AngleA -135.  def /AngleB 135.  def 0.67  0.67  NCCurve
 } if end  gsave 0.8 SLW 0  setgray  1. .setopacityalpha   1  setlinejoin
0  setlinecap stroke  grestore  grestore end
 452 2160 a 452 2160
a
tx@Dict begin  tx@NodeDict begin /t .5 def LPut end PutBegin  end
 452 2160 a 278 2189 a @beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { BeginArrow
2.  2.  scale  false 0.4 1.4 1.5 2.   1. .setopacityalpha  Arrow  EndArrow
 } def  0.0 SLW 1  setgray  0. true 3.0 neg 6.4 neg 44.8556 13.34444
.5 Frame  gsave 1  setgray  1. .setopacityalpha  fill  grestore end
 
@endspecial
28 w Fb(sk)n(eleton)p 278 2106 348 4 v 278 2216 4 111
v 622 2216 V 278 2218 348 4 v 452 2160 a
tx@Dict begin PutEnd  end
 452 2160 a 452
2160 a
tx@Dict begin gsave STV newpath /ArrowA { moveto } def /ArrowB { BeginArrow
2.  2.  scale  false 0.4 1.4 1.5 2.   1. .setopacityalpha  Arrow  EndArrow
 } def  0.8 SLW 0  setgray  /ArrowA { moveto } def /ArrowB { BeginArrow
2.  2.  scale  false 0.4 1.4 1.5 2.   1. .setopacityalpha  Arrow  EndArrow
 } def  /NCLW CLW def tx@NodeDict begin 0.0 0.0 neg 0.0 0.0 0 0 /N@S
/N@D InitNC { /AngleA 195.  def /AngleB 90.  def 0.67  0.67  NCCurve
 } if end  gsave 0.8 SLW 0  setgray  1. .setopacityalpha   1  setlinejoin
0  setlinecap stroke  grestore  grestore end
 452 2160 a 452 2160 a
tx@Dict begin  tx@NodeDict begin /t .5 def LPut end PutBegin  end
 452 2160 a 278 2189 a @beginspecial
@setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { BeginArrow
2.  2.  scale  false 0.4 1.4 1.5 2.   1. .setopacityalpha  Arrow  EndArrow
 } def  0.0 SLW 1  setgray  0. true 3.0 neg 6.4 neg 44.8556 13.34444
.5 Frame  gsave 1  setgray  1. .setopacityalpha  fill  grestore end
 
@endspecial 28 w Fb(sk)n(eleton)p 278 2106
348 4 v 278 2216 4 111 v 622 2216 V 278 2218 348 4 v
452 2160 a
tx@Dict begin PutEnd  end
 452 2160 a 452 2160 a
tx@Dict begin gsave STV newpath /ArrowA { moveto } def /ArrowB { BeginArrow
2.  2.  scale  false 0.4 1.4 1.5 2.   1. .setopacityalpha  Arrow  EndArrow
 } def  0.8 SLW 0  setgray  /ArrowA { moveto } def /ArrowB { BeginArrow
2.  2.  scale  false 0.4 1.4 1.5 2.   1. .setopacityalpha  Arrow  EndArrow
 } def  /NCLW CLW def tx@NodeDict begin 0.0 0.0 neg 0.0 0.0 0 0 /N@Sh
/N@D InitNC { /AngleA 195.  def /AngleB 45.  def 0.67  0.67  NCCurve
 } if end  gsave 0.8 SLW 0  setgray  1. .setopacityalpha   1  setlinejoin
0  setlinecap stroke  grestore  grestore end
 452 2160 a 452 2160
a
tx@Dict begin  tx@NodeDict begin /t .5 def LPut end PutBegin  end
 452 2160 a 278 2189 a @beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { BeginArrow
2.  2.  scale  false 0.4 1.4 1.5 2.   1. .setopacityalpha  Arrow  EndArrow
 } def  0.0 SLW 1  setgray  0. true 3.0 neg 6.4 neg 44.8556 13.34444
.5 Frame  gsave 1  setgray  1. .setopacityalpha  fill  grestore end
 
@endspecial
28 w Fb(sk)n(eleton)p 278 2106 348 4 v 278 2216 4 111
v 622 2216 V 278 2218 348 4 v 452 2160 a
tx@Dict begin PutEnd  end
 452 2160 a 452
2160 a
tx@Dict begin gsave STV newpath /ArrowA { moveto } def /ArrowB { BeginArrow
2.  2.  scale  false 0.4 1.4 1.5 2.   1. .setopacityalpha  Arrow  EndArrow
 } def  0.8 SLW 0  setgray  /ArrowA { moveto } def /ArrowB { BeginArrow
2.  2.  scale  false 0.4 1.4 1.5 2.   1. .setopacityalpha  Arrow  EndArrow
 } def  /NCLW CLW def tx@NodeDict begin 0.0 0.0 neg 0.0 0.0 0 0 /N@WN
/N@D InitNC { /AngleA -45.  def /AngleB 0.  def 0.67  0.67  NCCurve
 } if end  gsave 0.8 SLW 0  setgray  1. .setopacityalpha   1  setlinejoin
0  setlinecap stroke  grestore  grestore end
 452 2160 a 452 2160 a
tx@Dict begin  tx@NodeDict begin /t .5 def LPut end PutBegin  end
 452 2160 a 278 2189 a @beginspecial
@setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { BeginArrow
2.  2.  scale  false 0.4 1.4 1.5 2.   1. .setopacityalpha  Arrow  EndArrow
 } def  0.0 SLW 1  setgray  0. true 3.0 neg 6.4 neg 44.8556 13.34444
.5 Frame  gsave 1  setgray  1. .setopacityalpha  fill  grestore end
 
@endspecial 28 w Fb(sk)n(eleton)p 278 2106
348 4 v 278 2216 4 111 v 622 2216 V 278 2218 348 4 v
452 2160 a
tx@Dict begin PutEnd  end
 452 2160 a eop end
%%Trailer

userdict /end-hook known{end-hook}if
%%EOF
